# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.1
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

"""The TimeTagger module measures timing events very accurately."""

import weakref
from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")


# The Time Tagger library uses numpy to return array values
import numpy

try:
    import _TimeTagger
except:
    import platform
    if platform.system() != 'Windows':
        raise

    import sys
    import os

    assert 'TIMETAGGER_INSTALL_PATH' in os.environ, 'The Time Tagger installation was not found. Please reinstall the Time Tagger Software suite.'

    # detect bitness and python version
    arch = 'x64' if platform.architecture()[0] == '64bit' else 'x86'
    version = str(sys.version_info.major) + '.' + str(sys.version_info.minor)

    # absolute path for the TimeTagger module
    path = os.environ['TIMETAGGER_INSTALL_PATH'] + '\\driver\\' + arch + '\\python' + version

    # add the new path
    if not path in sys.path:
        sys.path.append(path)

    try:
        import _TimeTagger
    except:
        assert version in ['3.6', '3.7', '3.8', '3.9', '3.10', '3.11'], 'This Python version is not supported by the Time Tagger software suite.'
        raise

    # clear all local variables
    del platform, sys, os, arch, version, path


try:
    import builtins as __builtin__
except ImportError:
    import __builtin__


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


class SwigPyIterator(object):
    r"""Proxy of C++ swig::SwigPyIterator class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _TimeTagger.delete_SwigPyIterator

    def value(self) -> "PyObject *":
        r"""value(self) -> PyObject *"""
        return _TimeTagger.SwigPyIterator_value(self)

    def incr(self, n: "size_t" = 1) -> "swig::SwigPyIterator *":
        r"""incr(self, n=1) -> SwigPyIterator"""
        return _TimeTagger.SwigPyIterator_incr(self, n)

    def decr(self, n: "size_t" = 1) -> "swig::SwigPyIterator *":
        r"""decr(self, n=1) -> SwigPyIterator"""
        return _TimeTagger.SwigPyIterator_decr(self, n)

    def distance(self, x: "SwigPyIterator") -> "ptrdiff_t":
        r"""distance(self, x) -> ptrdiff_t"""
        return _TimeTagger.SwigPyIterator_distance(self, x)

    def equal(self, x: "SwigPyIterator") -> "bool":
        r"""equal(self, x) -> bool"""
        return _TimeTagger.SwigPyIterator_equal(self, x)

    def copy(self) -> "swig::SwigPyIterator *":
        r"""copy(self) -> SwigPyIterator"""
        return _TimeTagger.SwigPyIterator_copy(self)

    def next(self) -> "PyObject *":
        r"""next(self) -> PyObject *"""
        return _TimeTagger.SwigPyIterator_next(self)

    def __next__(self) -> "PyObject *":
        r"""__next__(self) -> PyObject *"""
        return _TimeTagger.SwigPyIterator___next__(self)

    def previous(self) -> "PyObject *":
        r"""previous(self) -> PyObject *"""
        return _TimeTagger.SwigPyIterator_previous(self)

    def advance(self, n: "ptrdiff_t") -> "swig::SwigPyIterator *":
        r"""advance(self, n) -> SwigPyIterator"""
        return _TimeTagger.SwigPyIterator_advance(self, n)

    def __eq__(self, x: "SwigPyIterator") -> "bool":
        r"""__eq__(self, x) -> bool"""
        return _TimeTagger.SwigPyIterator___eq__(self, x)

    def __ne__(self, x: "SwigPyIterator") -> "bool":
        r"""__ne__(self, x) -> bool"""
        return _TimeTagger.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator &":
        r"""__iadd__(self, n) -> SwigPyIterator"""
        return _TimeTagger.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator &":
        r"""__isub__(self, n) -> SwigPyIterator"""
        return _TimeTagger.SwigPyIterator___isub__(self, n)

    def __add__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator *":
        r"""__add__(self, n) -> SwigPyIterator"""
        return _TimeTagger.SwigPyIterator___add__(self, n)

    def __sub__(self, *args) -> "ptrdiff_t":
        r"""
        __sub__(self, n) -> SwigPyIterator
        __sub__(self, x) -> ptrdiff_t
        """
        return _TimeTagger.SwigPyIterator___sub__(self, *args)

    def __iter__(self):
        return self


# Register SwigPyIterator in _TimeTagger:
_TimeTagger.SwigPyIterator_swigregister(SwigPyIterator)


def _timeout_handler(callback, timeout):
    r"""
        helper for splitting up timeouts in smaller calls. So CTRL-C will be able to interrupt blocking calls.
        timeout is in milliseconds, 0 means non-blocking, negative means no timeout.
        returns True on success and False on timeout.
    """

    if timeout == 0:
        return callback(timeout)

    maximum_timeout = 20

    if timeout < 0:
        while not callback(maximum_timeout):
            pass
        return True

    import time
    original_time = time.monotonic()
    while True:
        remaining_timeout = max(0, min(maximum_timeout, timeout - round((time.monotonic() - original_time) * 1000)))
        if callback(remaining_timeout):
            return True
        if remaining_timeout == 0:
            return False


def getTimeTaggerServerInfo(*args, **kargs):
    r"""getTimeTaggerServerInfo(...) -> json"""
    import json
    return json.loads(__getTimeTaggerServerInfo(*args, **kargs))


def extractDeviceLicense(*args, **kargs):
    r"""extractDeviceLicense(...) -> json"""
    import json
    return json.loads(__extractDeviceLicense(*args, **kargs))


class UCharVector(object):
    r"""Proxy of C++ std::vector< unsigned char > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        r"""iterator(self) -> SwigPyIterator"""
        return _TimeTagger.UCharVector_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        r"""__nonzero__(self) -> bool"""
        return _TimeTagger.UCharVector___nonzero__(self)

    def __bool__(self) -> "bool":
        r"""__bool__(self) -> bool"""
        return _TimeTagger.UCharVector___bool__(self)

    def __len__(self) -> "std::vector< unsigned char >::size_type":
        r"""__len__(self) -> std::vector< unsigned char >::size_type"""
        return _TimeTagger.UCharVector___len__(self)

    def __getslice__(self, i: "std::vector< unsigned char >::difference_type", j: "std::vector< unsigned char >::difference_type") -> "std::vector< unsigned char,std::allocator< unsigned char > > *":
        r"""__getslice__(self, i, j) -> UCharVector"""
        return _TimeTagger.UCharVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        r"""
        __setslice__(self, i, j)
        __setslice__(self, i, j, v)
        """
        return _TimeTagger.UCharVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< unsigned char >::difference_type", j: "std::vector< unsigned char >::difference_type") -> "void":
        r"""__delslice__(self, i, j)"""
        return _TimeTagger.UCharVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        r"""
        __delitem__(self, i)
        __delitem__(self, slice)
        """
        return _TimeTagger.UCharVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< unsigned char >::value_type const &":
        r"""
        __getitem__(self, slice) -> UCharVector
        __getitem__(self, i) -> std::vector< unsigned char >::value_type const &
        """
        return _TimeTagger.UCharVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        r"""
        __setitem__(self, slice, v)
        __setitem__(self, slice)
        __setitem__(self, i, x)
        """
        return _TimeTagger.UCharVector___setitem__(self, *args)

    def pop(self) -> "std::vector< unsigned char >::value_type":
        r"""pop(self) -> std::vector< unsigned char >::value_type"""
        return _TimeTagger.UCharVector_pop(self)

    def append(self, x: "std::vector< unsigned char >::value_type const &") -> "void":
        r"""append(self, x)"""
        return _TimeTagger.UCharVector_append(self, x)

    def empty(self) -> "bool":
        r"""empty(self) -> bool"""
        return _TimeTagger.UCharVector_empty(self)

    def size(self) -> "std::vector< unsigned char >::size_type":
        r"""size(self) -> std::vector< unsigned char >::size_type"""
        return _TimeTagger.UCharVector_size(self)

    def swap(self, v: "UCharVector") -> "void":
        r"""swap(self, v)"""
        return _TimeTagger.UCharVector_swap(self, v)

    def begin(self) -> "std::vector< unsigned char >::iterator":
        r"""begin(self) -> std::vector< unsigned char >::iterator"""
        return _TimeTagger.UCharVector_begin(self)

    def end(self) -> "std::vector< unsigned char >::iterator":
        r"""end(self) -> std::vector< unsigned char >::iterator"""
        return _TimeTagger.UCharVector_end(self)

    def rbegin(self) -> "std::vector< unsigned char >::reverse_iterator":
        r"""rbegin(self) -> std::vector< unsigned char >::reverse_iterator"""
        return _TimeTagger.UCharVector_rbegin(self)

    def rend(self) -> "std::vector< unsigned char >::reverse_iterator":
        r"""rend(self) -> std::vector< unsigned char >::reverse_iterator"""
        return _TimeTagger.UCharVector_rend(self)

    def clear(self) -> "void":
        r"""clear(self)"""
        return _TimeTagger.UCharVector_clear(self)

    def get_allocator(self) -> "std::vector< unsigned char >::allocator_type":
        r"""get_allocator(self) -> std::vector< unsigned char >::allocator_type"""
        return _TimeTagger.UCharVector_get_allocator(self)

    def pop_back(self) -> "void":
        r"""pop_back(self)"""
        return _TimeTagger.UCharVector_pop_back(self)

    def erase(self, *args) -> "std::vector< unsigned char >::iterator":
        r"""
        erase(self, pos) -> std::vector< unsigned char >::iterator
        erase(self, first, last) -> std::vector< unsigned char >::iterator
        """
        return _TimeTagger.UCharVector_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(self) -> UCharVector
        __init__(self, other) -> UCharVector
        __init__(self, size) -> UCharVector
        __init__(self, size, value) -> UCharVector
        """
        _TimeTagger.UCharVector_swiginit(self, _TimeTagger.new_UCharVector(*args))

    def push_back(self, x: "std::vector< unsigned char >::value_type const &") -> "void":
        r"""push_back(self, x)"""
        return _TimeTagger.UCharVector_push_back(self, x)

    def front(self) -> "std::vector< unsigned char >::value_type const &":
        r"""front(self) -> std::vector< unsigned char >::value_type const &"""
        return _TimeTagger.UCharVector_front(self)

    def back(self) -> "std::vector< unsigned char >::value_type const &":
        r"""back(self) -> std::vector< unsigned char >::value_type const &"""
        return _TimeTagger.UCharVector_back(self)

    def assign(self, n: "std::vector< unsigned char >::size_type", x: "std::vector< unsigned char >::value_type const &") -> "void":
        r"""assign(self, n, x)"""
        return _TimeTagger.UCharVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        r"""
        resize(self, new_size)
        resize(self, new_size, x)
        """
        return _TimeTagger.UCharVector_resize(self, *args)

    def insert(self, *args) -> "void":
        r"""
        insert(self, pos, x) -> std::vector< unsigned char >::iterator
        insert(self, pos, n, x)
        """
        return _TimeTagger.UCharVector_insert(self, *args)

    def reserve(self, n: "std::vector< unsigned char >::size_type") -> "void":
        r"""reserve(self, n)"""
        return _TimeTagger.UCharVector_reserve(self, n)

    def capacity(self) -> "std::vector< unsigned char >::size_type":
        r"""capacity(self) -> std::vector< unsigned char >::size_type"""
        return _TimeTagger.UCharVector_capacity(self)
    __swig_destroy__ = _TimeTagger.delete_UCharVector


# Register UCharVector in _TimeTagger:
_TimeTagger.UCharVector_swigregister(UCharVector)


class IntVector(object):
    r"""Proxy of C++ std::vector< int > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        r"""iterator(self) -> SwigPyIterator"""
        return _TimeTagger.IntVector_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        r"""__nonzero__(self) -> bool"""
        return _TimeTagger.IntVector___nonzero__(self)

    def __bool__(self) -> "bool":
        r"""__bool__(self) -> bool"""
        return _TimeTagger.IntVector___bool__(self)

    def __len__(self) -> "std::vector< int >::size_type":
        r"""__len__(self) -> std::vector< int >::size_type"""
        return _TimeTagger.IntVector___len__(self)

    def __getslice__(self, i: "std::vector< int >::difference_type", j: "std::vector< int >::difference_type") -> "std::vector< int,std::allocator< int > > *":
        r"""__getslice__(self, i, j) -> IntVector"""
        return _TimeTagger.IntVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        r"""
        __setslice__(self, i, j)
        __setslice__(self, i, j, v)
        """
        return _TimeTagger.IntVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< int >::difference_type", j: "std::vector< int >::difference_type") -> "void":
        r"""__delslice__(self, i, j)"""
        return _TimeTagger.IntVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        r"""
        __delitem__(self, i)
        __delitem__(self, slice)
        """
        return _TimeTagger.IntVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< int >::value_type const &":
        r"""
        __getitem__(self, slice) -> IntVector
        __getitem__(self, i) -> std::vector< int >::value_type const &
        """
        return _TimeTagger.IntVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        r"""
        __setitem__(self, slice, v)
        __setitem__(self, slice)
        __setitem__(self, i, x)
        """
        return _TimeTagger.IntVector___setitem__(self, *args)

    def pop(self) -> "std::vector< int >::value_type":
        r"""pop(self) -> std::vector< int >::value_type"""
        return _TimeTagger.IntVector_pop(self)

    def append(self, x: "std::vector< int >::value_type const &") -> "void":
        r"""append(self, x)"""
        return _TimeTagger.IntVector_append(self, x)

    def empty(self) -> "bool":
        r"""empty(self) -> bool"""
        return _TimeTagger.IntVector_empty(self)

    def size(self) -> "std::vector< int >::size_type":
        r"""size(self) -> std::vector< int >::size_type"""
        return _TimeTagger.IntVector_size(self)

    def swap(self, v: "IntVector") -> "void":
        r"""swap(self, v)"""
        return _TimeTagger.IntVector_swap(self, v)

    def begin(self) -> "std::vector< int >::iterator":
        r"""begin(self) -> std::vector< int >::iterator"""
        return _TimeTagger.IntVector_begin(self)

    def end(self) -> "std::vector< int >::iterator":
        r"""end(self) -> std::vector< int >::iterator"""
        return _TimeTagger.IntVector_end(self)

    def rbegin(self) -> "std::vector< int >::reverse_iterator":
        r"""rbegin(self) -> std::vector< int >::reverse_iterator"""
        return _TimeTagger.IntVector_rbegin(self)

    def rend(self) -> "std::vector< int >::reverse_iterator":
        r"""rend(self) -> std::vector< int >::reverse_iterator"""
        return _TimeTagger.IntVector_rend(self)

    def clear(self) -> "void":
        r"""clear(self)"""
        return _TimeTagger.IntVector_clear(self)

    def get_allocator(self) -> "std::vector< int >::allocator_type":
        r"""get_allocator(self) -> std::vector< int >::allocator_type"""
        return _TimeTagger.IntVector_get_allocator(self)

    def pop_back(self) -> "void":
        r"""pop_back(self)"""
        return _TimeTagger.IntVector_pop_back(self)

    def erase(self, *args) -> "std::vector< int >::iterator":
        r"""
        erase(self, pos) -> std::vector< int >::iterator
        erase(self, first, last) -> std::vector< int >::iterator
        """
        return _TimeTagger.IntVector_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(self) -> IntVector
        __init__(self, other) -> IntVector
        __init__(self, size) -> IntVector
        __init__(self, size, value) -> IntVector
        """
        _TimeTagger.IntVector_swiginit(self, _TimeTagger.new_IntVector(*args))

    def push_back(self, x: "std::vector< int >::value_type const &") -> "void":
        r"""push_back(self, x)"""
        return _TimeTagger.IntVector_push_back(self, x)

    def front(self) -> "std::vector< int >::value_type const &":
        r"""front(self) -> std::vector< int >::value_type const &"""
        return _TimeTagger.IntVector_front(self)

    def back(self) -> "std::vector< int >::value_type const &":
        r"""back(self) -> std::vector< int >::value_type const &"""
        return _TimeTagger.IntVector_back(self)

    def assign(self, n: "std::vector< int >::size_type", x: "std::vector< int >::value_type const &") -> "void":
        r"""assign(self, n, x)"""
        return _TimeTagger.IntVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        r"""
        resize(self, new_size)
        resize(self, new_size, x)
        """
        return _TimeTagger.IntVector_resize(self, *args)

    def insert(self, *args) -> "void":
        r"""
        insert(self, pos, x) -> std::vector< int >::iterator
        insert(self, pos, n, x)
        """
        return _TimeTagger.IntVector_insert(self, *args)

    def reserve(self, n: "std::vector< int >::size_type") -> "void":
        r"""reserve(self, n)"""
        return _TimeTagger.IntVector_reserve(self, n)

    def capacity(self) -> "std::vector< int >::size_type":
        r"""capacity(self) -> std::vector< int >::size_type"""
        return _TimeTagger.IntVector_capacity(self)
    __swig_destroy__ = _TimeTagger.delete_IntVector


# Register IntVector in _TimeTagger:
_TimeTagger.IntVector_swigregister(IntVector)


class UIntVector(object):
    r"""Proxy of C++ std::vector< unsigned int > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        r"""iterator(self) -> SwigPyIterator"""
        return _TimeTagger.UIntVector_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        r"""__nonzero__(self) -> bool"""
        return _TimeTagger.UIntVector___nonzero__(self)

    def __bool__(self) -> "bool":
        r"""__bool__(self) -> bool"""
        return _TimeTagger.UIntVector___bool__(self)

    def __len__(self) -> "std::vector< unsigned int >::size_type":
        r"""__len__(self) -> std::vector< unsigned int >::size_type"""
        return _TimeTagger.UIntVector___len__(self)

    def __getslice__(self, i: "std::vector< unsigned int >::difference_type", j: "std::vector< unsigned int >::difference_type") -> "std::vector< unsigned int,std::allocator< unsigned int > > *":
        r"""__getslice__(self, i, j) -> UIntVector"""
        return _TimeTagger.UIntVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        r"""
        __setslice__(self, i, j)
        __setslice__(self, i, j, v)
        """
        return _TimeTagger.UIntVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< unsigned int >::difference_type", j: "std::vector< unsigned int >::difference_type") -> "void":
        r"""__delslice__(self, i, j)"""
        return _TimeTagger.UIntVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        r"""
        __delitem__(self, i)
        __delitem__(self, slice)
        """
        return _TimeTagger.UIntVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< unsigned int >::value_type const &":
        r"""
        __getitem__(self, slice) -> UIntVector
        __getitem__(self, i) -> std::vector< unsigned int >::value_type const &
        """
        return _TimeTagger.UIntVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        r"""
        __setitem__(self, slice, v)
        __setitem__(self, slice)
        __setitem__(self, i, x)
        """
        return _TimeTagger.UIntVector___setitem__(self, *args)

    def pop(self) -> "std::vector< unsigned int >::value_type":
        r"""pop(self) -> std::vector< unsigned int >::value_type"""
        return _TimeTagger.UIntVector_pop(self)

    def append(self, x: "std::vector< unsigned int >::value_type const &") -> "void":
        r"""append(self, x)"""
        return _TimeTagger.UIntVector_append(self, x)

    def empty(self) -> "bool":
        r"""empty(self) -> bool"""
        return _TimeTagger.UIntVector_empty(self)

    def size(self) -> "std::vector< unsigned int >::size_type":
        r"""size(self) -> std::vector< unsigned int >::size_type"""
        return _TimeTagger.UIntVector_size(self)

    def swap(self, v: "UIntVector") -> "void":
        r"""swap(self, v)"""
        return _TimeTagger.UIntVector_swap(self, v)

    def begin(self) -> "std::vector< unsigned int >::iterator":
        r"""begin(self) -> std::vector< unsigned int >::iterator"""
        return _TimeTagger.UIntVector_begin(self)

    def end(self) -> "std::vector< unsigned int >::iterator":
        r"""end(self) -> std::vector< unsigned int >::iterator"""
        return _TimeTagger.UIntVector_end(self)

    def rbegin(self) -> "std::vector< unsigned int >::reverse_iterator":
        r"""rbegin(self) -> std::vector< unsigned int >::reverse_iterator"""
        return _TimeTagger.UIntVector_rbegin(self)

    def rend(self) -> "std::vector< unsigned int >::reverse_iterator":
        r"""rend(self) -> std::vector< unsigned int >::reverse_iterator"""
        return _TimeTagger.UIntVector_rend(self)

    def clear(self) -> "void":
        r"""clear(self)"""
        return _TimeTagger.UIntVector_clear(self)

    def get_allocator(self) -> "std::vector< unsigned int >::allocator_type":
        r"""get_allocator(self) -> std::vector< unsigned int >::allocator_type"""
        return _TimeTagger.UIntVector_get_allocator(self)

    def pop_back(self) -> "void":
        r"""pop_back(self)"""
        return _TimeTagger.UIntVector_pop_back(self)

    def erase(self, *args) -> "std::vector< unsigned int >::iterator":
        r"""
        erase(self, pos) -> std::vector< unsigned int >::iterator
        erase(self, first, last) -> std::vector< unsigned int >::iterator
        """
        return _TimeTagger.UIntVector_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(self) -> UIntVector
        __init__(self, other) -> UIntVector
        __init__(self, size) -> UIntVector
        __init__(self, size, value) -> UIntVector
        """
        _TimeTagger.UIntVector_swiginit(self, _TimeTagger.new_UIntVector(*args))

    def push_back(self, x: "std::vector< unsigned int >::value_type const &") -> "void":
        r"""push_back(self, x)"""
        return _TimeTagger.UIntVector_push_back(self, x)

    def front(self) -> "std::vector< unsigned int >::value_type const &":
        r"""front(self) -> std::vector< unsigned int >::value_type const &"""
        return _TimeTagger.UIntVector_front(self)

    def back(self) -> "std::vector< unsigned int >::value_type const &":
        r"""back(self) -> std::vector< unsigned int >::value_type const &"""
        return _TimeTagger.UIntVector_back(self)

    def assign(self, n: "std::vector< unsigned int >::size_type", x: "std::vector< unsigned int >::value_type const &") -> "void":
        r"""assign(self, n, x)"""
        return _TimeTagger.UIntVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        r"""
        resize(self, new_size)
        resize(self, new_size, x)
        """
        return _TimeTagger.UIntVector_resize(self, *args)

    def insert(self, *args) -> "void":
        r"""
        insert(self, pos, x) -> std::vector< unsigned int >::iterator
        insert(self, pos, n, x)
        """
        return _TimeTagger.UIntVector_insert(self, *args)

    def reserve(self, n: "std::vector< unsigned int >::size_type") -> "void":
        r"""reserve(self, n)"""
        return _TimeTagger.UIntVector_reserve(self, n)

    def capacity(self) -> "std::vector< unsigned int >::size_type":
        r"""capacity(self) -> std::vector< unsigned int >::size_type"""
        return _TimeTagger.UIntVector_capacity(self)
    __swig_destroy__ = _TimeTagger.delete_UIntVector


# Register UIntVector in _TimeTagger:
_TimeTagger.UIntVector_swigregister(UIntVector)


class LongVector(object):
    r"""Proxy of C++ std::vector< long > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        r"""iterator(self) -> SwigPyIterator"""
        return _TimeTagger.LongVector_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        r"""__nonzero__(self) -> bool"""
        return _TimeTagger.LongVector___nonzero__(self)

    def __bool__(self) -> "bool":
        r"""__bool__(self) -> bool"""
        return _TimeTagger.LongVector___bool__(self)

    def __len__(self) -> "std::vector< long >::size_type":
        r"""__len__(self) -> std::vector< long >::size_type"""
        return _TimeTagger.LongVector___len__(self)

    def __getslice__(self, i: "std::vector< long >::difference_type", j: "std::vector< long >::difference_type") -> "std::vector< long,std::allocator< long > > *":
        r"""__getslice__(self, i, j) -> LongVector"""
        return _TimeTagger.LongVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        r"""
        __setslice__(self, i, j)
        __setslice__(self, i, j, v)
        """
        return _TimeTagger.LongVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< long >::difference_type", j: "std::vector< long >::difference_type") -> "void":
        r"""__delslice__(self, i, j)"""
        return _TimeTagger.LongVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        r"""
        __delitem__(self, i)
        __delitem__(self, slice)
        """
        return _TimeTagger.LongVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< long >::value_type const &":
        r"""
        __getitem__(self, slice) -> LongVector
        __getitem__(self, i) -> std::vector< long >::value_type const &
        """
        return _TimeTagger.LongVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        r"""
        __setitem__(self, slice, v)
        __setitem__(self, slice)
        __setitem__(self, i, x)
        """
        return _TimeTagger.LongVector___setitem__(self, *args)

    def pop(self) -> "std::vector< long >::value_type":
        r"""pop(self) -> std::vector< long >::value_type"""
        return _TimeTagger.LongVector_pop(self)

    def append(self, x: "std::vector< long >::value_type const &") -> "void":
        r"""append(self, x)"""
        return _TimeTagger.LongVector_append(self, x)

    def empty(self) -> "bool":
        r"""empty(self) -> bool"""
        return _TimeTagger.LongVector_empty(self)

    def size(self) -> "std::vector< long >::size_type":
        r"""size(self) -> std::vector< long >::size_type"""
        return _TimeTagger.LongVector_size(self)

    def swap(self, v: "LongVector") -> "void":
        r"""swap(self, v)"""
        return _TimeTagger.LongVector_swap(self, v)

    def begin(self) -> "std::vector< long >::iterator":
        r"""begin(self) -> std::vector< long >::iterator"""
        return _TimeTagger.LongVector_begin(self)

    def end(self) -> "std::vector< long >::iterator":
        r"""end(self) -> std::vector< long >::iterator"""
        return _TimeTagger.LongVector_end(self)

    def rbegin(self) -> "std::vector< long >::reverse_iterator":
        r"""rbegin(self) -> std::vector< long >::reverse_iterator"""
        return _TimeTagger.LongVector_rbegin(self)

    def rend(self) -> "std::vector< long >::reverse_iterator":
        r"""rend(self) -> std::vector< long >::reverse_iterator"""
        return _TimeTagger.LongVector_rend(self)

    def clear(self) -> "void":
        r"""clear(self)"""
        return _TimeTagger.LongVector_clear(self)

    def get_allocator(self) -> "std::vector< long >::allocator_type":
        r"""get_allocator(self) -> std::vector< long >::allocator_type"""
        return _TimeTagger.LongVector_get_allocator(self)

    def pop_back(self) -> "void":
        r"""pop_back(self)"""
        return _TimeTagger.LongVector_pop_back(self)

    def erase(self, *args) -> "std::vector< long >::iterator":
        r"""
        erase(self, pos) -> std::vector< long >::iterator
        erase(self, first, last) -> std::vector< long >::iterator
        """
        return _TimeTagger.LongVector_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(self) -> LongVector
        __init__(self, other) -> LongVector
        __init__(self, size) -> LongVector
        __init__(self, size, value) -> LongVector
        """
        _TimeTagger.LongVector_swiginit(self, _TimeTagger.new_LongVector(*args))

    def push_back(self, x: "std::vector< long >::value_type const &") -> "void":
        r"""push_back(self, x)"""
        return _TimeTagger.LongVector_push_back(self, x)

    def front(self) -> "std::vector< long >::value_type const &":
        r"""front(self) -> std::vector< long >::value_type const &"""
        return _TimeTagger.LongVector_front(self)

    def back(self) -> "std::vector< long >::value_type const &":
        r"""back(self) -> std::vector< long >::value_type const &"""
        return _TimeTagger.LongVector_back(self)

    def assign(self, n: "std::vector< long >::size_type", x: "std::vector< long >::value_type const &") -> "void":
        r"""assign(self, n, x)"""
        return _TimeTagger.LongVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        r"""
        resize(self, new_size)
        resize(self, new_size, x)
        """
        return _TimeTagger.LongVector_resize(self, *args)

    def insert(self, *args) -> "void":
        r"""
        insert(self, pos, x) -> std::vector< long >::iterator
        insert(self, pos, n, x)
        """
        return _TimeTagger.LongVector_insert(self, *args)

    def reserve(self, n: "std::vector< long >::size_type") -> "void":
        r"""reserve(self, n)"""
        return _TimeTagger.LongVector_reserve(self, n)

    def capacity(self) -> "std::vector< long >::size_type":
        r"""capacity(self) -> std::vector< long >::size_type"""
        return _TimeTagger.LongVector_capacity(self)
    __swig_destroy__ = _TimeTagger.delete_LongVector


# Register LongVector in _TimeTagger:
_TimeTagger.LongVector_swigregister(LongVector)


class ULongVector(object):
    r"""Proxy of C++ std::vector< unsigned long > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        r"""iterator(self) -> SwigPyIterator"""
        return _TimeTagger.ULongVector_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        r"""__nonzero__(self) -> bool"""
        return _TimeTagger.ULongVector___nonzero__(self)

    def __bool__(self) -> "bool":
        r"""__bool__(self) -> bool"""
        return _TimeTagger.ULongVector___bool__(self)

    def __len__(self) -> "std::vector< unsigned long >::size_type":
        r"""__len__(self) -> std::vector< unsigned long >::size_type"""
        return _TimeTagger.ULongVector___len__(self)

    def __getslice__(self, i: "std::vector< unsigned long >::difference_type", j: "std::vector< unsigned long >::difference_type") -> "std::vector< unsigned long,std::allocator< unsigned long > > *":
        r"""__getslice__(self, i, j) -> ULongVector"""
        return _TimeTagger.ULongVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        r"""
        __setslice__(self, i, j)
        __setslice__(self, i, j, v)
        """
        return _TimeTagger.ULongVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< unsigned long >::difference_type", j: "std::vector< unsigned long >::difference_type") -> "void":
        r"""__delslice__(self, i, j)"""
        return _TimeTagger.ULongVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        r"""
        __delitem__(self, i)
        __delitem__(self, slice)
        """
        return _TimeTagger.ULongVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< unsigned long >::value_type const &":
        r"""
        __getitem__(self, slice) -> ULongVector
        __getitem__(self, i) -> std::vector< unsigned long >::value_type const &
        """
        return _TimeTagger.ULongVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        r"""
        __setitem__(self, slice, v)
        __setitem__(self, slice)
        __setitem__(self, i, x)
        """
        return _TimeTagger.ULongVector___setitem__(self, *args)

    def pop(self) -> "std::vector< unsigned long >::value_type":
        r"""pop(self) -> std::vector< unsigned long >::value_type"""
        return _TimeTagger.ULongVector_pop(self)

    def append(self, x: "std::vector< unsigned long >::value_type const &") -> "void":
        r"""append(self, x)"""
        return _TimeTagger.ULongVector_append(self, x)

    def empty(self) -> "bool":
        r"""empty(self) -> bool"""
        return _TimeTagger.ULongVector_empty(self)

    def size(self) -> "std::vector< unsigned long >::size_type":
        r"""size(self) -> std::vector< unsigned long >::size_type"""
        return _TimeTagger.ULongVector_size(self)

    def swap(self, v: "ULongVector") -> "void":
        r"""swap(self, v)"""
        return _TimeTagger.ULongVector_swap(self, v)

    def begin(self) -> "std::vector< unsigned long >::iterator":
        r"""begin(self) -> std::vector< unsigned long >::iterator"""
        return _TimeTagger.ULongVector_begin(self)

    def end(self) -> "std::vector< unsigned long >::iterator":
        r"""end(self) -> std::vector< unsigned long >::iterator"""
        return _TimeTagger.ULongVector_end(self)

    def rbegin(self) -> "std::vector< unsigned long >::reverse_iterator":
        r"""rbegin(self) -> std::vector< unsigned long >::reverse_iterator"""
        return _TimeTagger.ULongVector_rbegin(self)

    def rend(self) -> "std::vector< unsigned long >::reverse_iterator":
        r"""rend(self) -> std::vector< unsigned long >::reverse_iterator"""
        return _TimeTagger.ULongVector_rend(self)

    def clear(self) -> "void":
        r"""clear(self)"""
        return _TimeTagger.ULongVector_clear(self)

    def get_allocator(self) -> "std::vector< unsigned long >::allocator_type":
        r"""get_allocator(self) -> std::vector< unsigned long >::allocator_type"""
        return _TimeTagger.ULongVector_get_allocator(self)

    def pop_back(self) -> "void":
        r"""pop_back(self)"""
        return _TimeTagger.ULongVector_pop_back(self)

    def erase(self, *args) -> "std::vector< unsigned long >::iterator":
        r"""
        erase(self, pos) -> std::vector< unsigned long >::iterator
        erase(self, first, last) -> std::vector< unsigned long >::iterator
        """
        return _TimeTagger.ULongVector_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(self) -> ULongVector
        __init__(self, other) -> ULongVector
        __init__(self, size) -> ULongVector
        __init__(self, size, value) -> ULongVector
        """
        _TimeTagger.ULongVector_swiginit(self, _TimeTagger.new_ULongVector(*args))

    def push_back(self, x: "std::vector< unsigned long >::value_type const &") -> "void":
        r"""push_back(self, x)"""
        return _TimeTagger.ULongVector_push_back(self, x)

    def front(self) -> "std::vector< unsigned long >::value_type const &":
        r"""front(self) -> std::vector< unsigned long >::value_type const &"""
        return _TimeTagger.ULongVector_front(self)

    def back(self) -> "std::vector< unsigned long >::value_type const &":
        r"""back(self) -> std::vector< unsigned long >::value_type const &"""
        return _TimeTagger.ULongVector_back(self)

    def assign(self, n: "std::vector< unsigned long >::size_type", x: "std::vector< unsigned long >::value_type const &") -> "void":
        r"""assign(self, n, x)"""
        return _TimeTagger.ULongVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        r"""
        resize(self, new_size)
        resize(self, new_size, x)
        """
        return _TimeTagger.ULongVector_resize(self, *args)

    def insert(self, *args) -> "void":
        r"""
        insert(self, pos, x) -> std::vector< unsigned long >::iterator
        insert(self, pos, n, x)
        """
        return _TimeTagger.ULongVector_insert(self, *args)

    def reserve(self, n: "std::vector< unsigned long >::size_type") -> "void":
        r"""reserve(self, n)"""
        return _TimeTagger.ULongVector_reserve(self, n)

    def capacity(self) -> "std::vector< unsigned long >::size_type":
        r"""capacity(self) -> std::vector< unsigned long >::size_type"""
        return _TimeTagger.ULongVector_capacity(self)
    __swig_destroy__ = _TimeTagger.delete_ULongVector


# Register ULongVector in _TimeTagger:
_TimeTagger.ULongVector_swigregister(ULongVector)


class LongLongVector(object):
    r"""Proxy of C++ std::vector< long long > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        r"""iterator(self) -> SwigPyIterator"""
        return _TimeTagger.LongLongVector_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        r"""__nonzero__(self) -> bool"""
        return _TimeTagger.LongLongVector___nonzero__(self)

    def __bool__(self) -> "bool":
        r"""__bool__(self) -> bool"""
        return _TimeTagger.LongLongVector___bool__(self)

    def __len__(self) -> "std::vector< long long >::size_type":
        r"""__len__(self) -> std::vector< long long >::size_type"""
        return _TimeTagger.LongLongVector___len__(self)

    def __getslice__(self, i: "std::vector< long long >::difference_type", j: "std::vector< long long >::difference_type") -> "std::vector< long long,std::allocator< long long > > *":
        r"""__getslice__(self, i, j) -> LongLongVector"""
        return _TimeTagger.LongLongVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        r"""
        __setslice__(self, i, j)
        __setslice__(self, i, j, v)
        """
        return _TimeTagger.LongLongVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< long long >::difference_type", j: "std::vector< long long >::difference_type") -> "void":
        r"""__delslice__(self, i, j)"""
        return _TimeTagger.LongLongVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        r"""
        __delitem__(self, i)
        __delitem__(self, slice)
        """
        return _TimeTagger.LongLongVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< long long >::value_type const &":
        r"""
        __getitem__(self, slice) -> LongLongVector
        __getitem__(self, i) -> std::vector< long long >::value_type const &
        """
        return _TimeTagger.LongLongVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        r"""
        __setitem__(self, slice, v)
        __setitem__(self, slice)
        __setitem__(self, i, x)
        """
        return _TimeTagger.LongLongVector___setitem__(self, *args)

    def pop(self) -> "std::vector< long long >::value_type":
        r"""pop(self) -> std::vector< long long >::value_type"""
        return _TimeTagger.LongLongVector_pop(self)

    def append(self, x: "std::vector< long long >::value_type const &") -> "void":
        r"""append(self, x)"""
        return _TimeTagger.LongLongVector_append(self, x)

    def empty(self) -> "bool":
        r"""empty(self) -> bool"""
        return _TimeTagger.LongLongVector_empty(self)

    def size(self) -> "std::vector< long long >::size_type":
        r"""size(self) -> std::vector< long long >::size_type"""
        return _TimeTagger.LongLongVector_size(self)

    def swap(self, v: "LongLongVector") -> "void":
        r"""swap(self, v)"""
        return _TimeTagger.LongLongVector_swap(self, v)

    def begin(self) -> "std::vector< long long >::iterator":
        r"""begin(self) -> std::vector< long long >::iterator"""
        return _TimeTagger.LongLongVector_begin(self)

    def end(self) -> "std::vector< long long >::iterator":
        r"""end(self) -> std::vector< long long >::iterator"""
        return _TimeTagger.LongLongVector_end(self)

    def rbegin(self) -> "std::vector< long long >::reverse_iterator":
        r"""rbegin(self) -> std::vector< long long >::reverse_iterator"""
        return _TimeTagger.LongLongVector_rbegin(self)

    def rend(self) -> "std::vector< long long >::reverse_iterator":
        r"""rend(self) -> std::vector< long long >::reverse_iterator"""
        return _TimeTagger.LongLongVector_rend(self)

    def clear(self) -> "void":
        r"""clear(self)"""
        return _TimeTagger.LongLongVector_clear(self)

    def get_allocator(self) -> "std::vector< long long >::allocator_type":
        r"""get_allocator(self) -> std::vector< long long >::allocator_type"""
        return _TimeTagger.LongLongVector_get_allocator(self)

    def pop_back(self) -> "void":
        r"""pop_back(self)"""
        return _TimeTagger.LongLongVector_pop_back(self)

    def erase(self, *args) -> "std::vector< long long >::iterator":
        r"""
        erase(self, pos) -> std::vector< long long >::iterator
        erase(self, first, last) -> std::vector< long long >::iterator
        """
        return _TimeTagger.LongLongVector_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(self) -> LongLongVector
        __init__(self, other) -> LongLongVector
        __init__(self, size) -> LongLongVector
        __init__(self, size, value) -> LongLongVector
        """
        _TimeTagger.LongLongVector_swiginit(self, _TimeTagger.new_LongLongVector(*args))

    def push_back(self, x: "std::vector< long long >::value_type const &") -> "void":
        r"""push_back(self, x)"""
        return _TimeTagger.LongLongVector_push_back(self, x)

    def front(self) -> "std::vector< long long >::value_type const &":
        r"""front(self) -> std::vector< long long >::value_type const &"""
        return _TimeTagger.LongLongVector_front(self)

    def back(self) -> "std::vector< long long >::value_type const &":
        r"""back(self) -> std::vector< long long >::value_type const &"""
        return _TimeTagger.LongLongVector_back(self)

    def assign(self, n: "std::vector< long long >::size_type", x: "std::vector< long long >::value_type const &") -> "void":
        r"""assign(self, n, x)"""
        return _TimeTagger.LongLongVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        r"""
        resize(self, new_size)
        resize(self, new_size, x)
        """
        return _TimeTagger.LongLongVector_resize(self, *args)

    def insert(self, *args) -> "void":
        r"""
        insert(self, pos, x) -> std::vector< long long >::iterator
        insert(self, pos, n, x)
        """
        return _TimeTagger.LongLongVector_insert(self, *args)

    def reserve(self, n: "std::vector< long long >::size_type") -> "void":
        r"""reserve(self, n)"""
        return _TimeTagger.LongLongVector_reserve(self, n)

    def capacity(self) -> "std::vector< long long >::size_type":
        r"""capacity(self) -> std::vector< long long >::size_type"""
        return _TimeTagger.LongLongVector_capacity(self)
    __swig_destroy__ = _TimeTagger.delete_LongLongVector


# Register LongLongVector in _TimeTagger:
_TimeTagger.LongLongVector_swigregister(LongLongVector)


class ULongLongVector(object):
    r"""Proxy of C++ std::vector< unsigned long long > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        r"""iterator(self) -> SwigPyIterator"""
        return _TimeTagger.ULongLongVector_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        r"""__nonzero__(self) -> bool"""
        return _TimeTagger.ULongLongVector___nonzero__(self)

    def __bool__(self) -> "bool":
        r"""__bool__(self) -> bool"""
        return _TimeTagger.ULongLongVector___bool__(self)

    def __len__(self) -> "std::vector< unsigned long long >::size_type":
        r"""__len__(self) -> std::vector< unsigned long long >::size_type"""
        return _TimeTagger.ULongLongVector___len__(self)

    def __getslice__(self, i: "std::vector< unsigned long long >::difference_type", j: "std::vector< unsigned long long >::difference_type") -> "std::vector< unsigned long long,std::allocator< unsigned long long > > *":
        r"""__getslice__(self, i, j) -> ULongLongVector"""
        return _TimeTagger.ULongLongVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        r"""
        __setslice__(self, i, j)
        __setslice__(self, i, j, v)
        """
        return _TimeTagger.ULongLongVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< unsigned long long >::difference_type", j: "std::vector< unsigned long long >::difference_type") -> "void":
        r"""__delslice__(self, i, j)"""
        return _TimeTagger.ULongLongVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        r"""
        __delitem__(self, i)
        __delitem__(self, slice)
        """
        return _TimeTagger.ULongLongVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< unsigned long long >::value_type const &":
        r"""
        __getitem__(self, slice) -> ULongLongVector
        __getitem__(self, i) -> std::vector< unsigned long long >::value_type const &
        """
        return _TimeTagger.ULongLongVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        r"""
        __setitem__(self, slice, v)
        __setitem__(self, slice)
        __setitem__(self, i, x)
        """
        return _TimeTagger.ULongLongVector___setitem__(self, *args)

    def pop(self) -> "std::vector< unsigned long long >::value_type":
        r"""pop(self) -> std::vector< unsigned long long >::value_type"""
        return _TimeTagger.ULongLongVector_pop(self)

    def append(self, x: "std::vector< unsigned long long >::value_type const &") -> "void":
        r"""append(self, x)"""
        return _TimeTagger.ULongLongVector_append(self, x)

    def empty(self) -> "bool":
        r"""empty(self) -> bool"""
        return _TimeTagger.ULongLongVector_empty(self)

    def size(self) -> "std::vector< unsigned long long >::size_type":
        r"""size(self) -> std::vector< unsigned long long >::size_type"""
        return _TimeTagger.ULongLongVector_size(self)

    def swap(self, v: "ULongLongVector") -> "void":
        r"""swap(self, v)"""
        return _TimeTagger.ULongLongVector_swap(self, v)

    def begin(self) -> "std::vector< unsigned long long >::iterator":
        r"""begin(self) -> std::vector< unsigned long long >::iterator"""
        return _TimeTagger.ULongLongVector_begin(self)

    def end(self) -> "std::vector< unsigned long long >::iterator":
        r"""end(self) -> std::vector< unsigned long long >::iterator"""
        return _TimeTagger.ULongLongVector_end(self)

    def rbegin(self) -> "std::vector< unsigned long long >::reverse_iterator":
        r"""rbegin(self) -> std::vector< unsigned long long >::reverse_iterator"""
        return _TimeTagger.ULongLongVector_rbegin(self)

    def rend(self) -> "std::vector< unsigned long long >::reverse_iterator":
        r"""rend(self) -> std::vector< unsigned long long >::reverse_iterator"""
        return _TimeTagger.ULongLongVector_rend(self)

    def clear(self) -> "void":
        r"""clear(self)"""
        return _TimeTagger.ULongLongVector_clear(self)

    def get_allocator(self) -> "std::vector< unsigned long long >::allocator_type":
        r"""get_allocator(self) -> std::vector< unsigned long long >::allocator_type"""
        return _TimeTagger.ULongLongVector_get_allocator(self)

    def pop_back(self) -> "void":
        r"""pop_back(self)"""
        return _TimeTagger.ULongLongVector_pop_back(self)

    def erase(self, *args) -> "std::vector< unsigned long long >::iterator":
        r"""
        erase(self, pos) -> std::vector< unsigned long long >::iterator
        erase(self, first, last) -> std::vector< unsigned long long >::iterator
        """
        return _TimeTagger.ULongLongVector_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(self) -> ULongLongVector
        __init__(self, other) -> ULongLongVector
        __init__(self, size) -> ULongLongVector
        __init__(self, size, value) -> ULongLongVector
        """
        _TimeTagger.ULongLongVector_swiginit(self, _TimeTagger.new_ULongLongVector(*args))

    def push_back(self, x: "std::vector< unsigned long long >::value_type const &") -> "void":
        r"""push_back(self, x)"""
        return _TimeTagger.ULongLongVector_push_back(self, x)

    def front(self) -> "std::vector< unsigned long long >::value_type const &":
        r"""front(self) -> std::vector< unsigned long long >::value_type const &"""
        return _TimeTagger.ULongLongVector_front(self)

    def back(self) -> "std::vector< unsigned long long >::value_type const &":
        r"""back(self) -> std::vector< unsigned long long >::value_type const &"""
        return _TimeTagger.ULongLongVector_back(self)

    def assign(self, n: "std::vector< unsigned long long >::size_type", x: "std::vector< unsigned long long >::value_type const &") -> "void":
        r"""assign(self, n, x)"""
        return _TimeTagger.ULongLongVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        r"""
        resize(self, new_size)
        resize(self, new_size, x)
        """
        return _TimeTagger.ULongLongVector_resize(self, *args)

    def insert(self, *args) -> "void":
        r"""
        insert(self, pos, x) -> std::vector< unsigned long long >::iterator
        insert(self, pos, n, x)
        """
        return _TimeTagger.ULongLongVector_insert(self, *args)

    def reserve(self, n: "std::vector< unsigned long long >::size_type") -> "void":
        r"""reserve(self, n)"""
        return _TimeTagger.ULongLongVector_reserve(self, n)

    def capacity(self) -> "std::vector< unsigned long long >::size_type":
        r"""capacity(self) -> std::vector< unsigned long long >::size_type"""
        return _TimeTagger.ULongLongVector_capacity(self)
    __swig_destroy__ = _TimeTagger.delete_ULongLongVector


# Register ULongLongVector in _TimeTagger:
_TimeTagger.ULongLongVector_swigregister(ULongLongVector)


class FloatVector(object):
    r"""Proxy of C++ std::vector< float > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        r"""iterator(self) -> SwigPyIterator"""
        return _TimeTagger.FloatVector_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        r"""__nonzero__(self) -> bool"""
        return _TimeTagger.FloatVector___nonzero__(self)

    def __bool__(self) -> "bool":
        r"""__bool__(self) -> bool"""
        return _TimeTagger.FloatVector___bool__(self)

    def __len__(self) -> "std::vector< float >::size_type":
        r"""__len__(self) -> std::vector< float >::size_type"""
        return _TimeTagger.FloatVector___len__(self)

    def __getslice__(self, i: "std::vector< float >::difference_type", j: "std::vector< float >::difference_type") -> "std::vector< float,std::allocator< float > > *":
        r"""__getslice__(self, i, j) -> FloatVector"""
        return _TimeTagger.FloatVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        r"""
        __setslice__(self, i, j)
        __setslice__(self, i, j, v)
        """
        return _TimeTagger.FloatVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< float >::difference_type", j: "std::vector< float >::difference_type") -> "void":
        r"""__delslice__(self, i, j)"""
        return _TimeTagger.FloatVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        r"""
        __delitem__(self, i)
        __delitem__(self, slice)
        """
        return _TimeTagger.FloatVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< float >::value_type const &":
        r"""
        __getitem__(self, slice) -> FloatVector
        __getitem__(self, i) -> std::vector< float >::value_type const &
        """
        return _TimeTagger.FloatVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        r"""
        __setitem__(self, slice, v)
        __setitem__(self, slice)
        __setitem__(self, i, x)
        """
        return _TimeTagger.FloatVector___setitem__(self, *args)

    def pop(self) -> "std::vector< float >::value_type":
        r"""pop(self) -> std::vector< float >::value_type"""
        return _TimeTagger.FloatVector_pop(self)

    def append(self, x: "std::vector< float >::value_type const &") -> "void":
        r"""append(self, x)"""
        return _TimeTagger.FloatVector_append(self, x)

    def empty(self) -> "bool":
        r"""empty(self) -> bool"""
        return _TimeTagger.FloatVector_empty(self)

    def size(self) -> "std::vector< float >::size_type":
        r"""size(self) -> std::vector< float >::size_type"""
        return _TimeTagger.FloatVector_size(self)

    def swap(self, v: "FloatVector") -> "void":
        r"""swap(self, v)"""
        return _TimeTagger.FloatVector_swap(self, v)

    def begin(self) -> "std::vector< float >::iterator":
        r"""begin(self) -> std::vector< float >::iterator"""
        return _TimeTagger.FloatVector_begin(self)

    def end(self) -> "std::vector< float >::iterator":
        r"""end(self) -> std::vector< float >::iterator"""
        return _TimeTagger.FloatVector_end(self)

    def rbegin(self) -> "std::vector< float >::reverse_iterator":
        r"""rbegin(self) -> std::vector< float >::reverse_iterator"""
        return _TimeTagger.FloatVector_rbegin(self)

    def rend(self) -> "std::vector< float >::reverse_iterator":
        r"""rend(self) -> std::vector< float >::reverse_iterator"""
        return _TimeTagger.FloatVector_rend(self)

    def clear(self) -> "void":
        r"""clear(self)"""
        return _TimeTagger.FloatVector_clear(self)

    def get_allocator(self) -> "std::vector< float >::allocator_type":
        r"""get_allocator(self) -> std::vector< float >::allocator_type"""
        return _TimeTagger.FloatVector_get_allocator(self)

    def pop_back(self) -> "void":
        r"""pop_back(self)"""
        return _TimeTagger.FloatVector_pop_back(self)

    def erase(self, *args) -> "std::vector< float >::iterator":
        r"""
        erase(self, pos) -> std::vector< float >::iterator
        erase(self, first, last) -> std::vector< float >::iterator
        """
        return _TimeTagger.FloatVector_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(self) -> FloatVector
        __init__(self, other) -> FloatVector
        __init__(self, size) -> FloatVector
        __init__(self, size, value) -> FloatVector
        """
        _TimeTagger.FloatVector_swiginit(self, _TimeTagger.new_FloatVector(*args))

    def push_back(self, x: "std::vector< float >::value_type const &") -> "void":
        r"""push_back(self, x)"""
        return _TimeTagger.FloatVector_push_back(self, x)

    def front(self) -> "std::vector< float >::value_type const &":
        r"""front(self) -> std::vector< float >::value_type const &"""
        return _TimeTagger.FloatVector_front(self)

    def back(self) -> "std::vector< float >::value_type const &":
        r"""back(self) -> std::vector< float >::value_type const &"""
        return _TimeTagger.FloatVector_back(self)

    def assign(self, n: "std::vector< float >::size_type", x: "std::vector< float >::value_type const &") -> "void":
        r"""assign(self, n, x)"""
        return _TimeTagger.FloatVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        r"""
        resize(self, new_size)
        resize(self, new_size, x)
        """
        return _TimeTagger.FloatVector_resize(self, *args)

    def insert(self, *args) -> "void":
        r"""
        insert(self, pos, x) -> std::vector< float >::iterator
        insert(self, pos, n, x)
        """
        return _TimeTagger.FloatVector_insert(self, *args)

    def reserve(self, n: "std::vector< float >::size_type") -> "void":
        r"""reserve(self, n)"""
        return _TimeTagger.FloatVector_reserve(self, n)

    def capacity(self) -> "std::vector< float >::size_type":
        r"""capacity(self) -> std::vector< float >::size_type"""
        return _TimeTagger.FloatVector_capacity(self)
    __swig_destroy__ = _TimeTagger.delete_FloatVector


# Register FloatVector in _TimeTagger:
_TimeTagger.FloatVector_swigregister(FloatVector)


class DoubleVector(object):
    r"""Proxy of C++ std::vector< double > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        r"""iterator(self) -> SwigPyIterator"""
        return _TimeTagger.DoubleVector_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        r"""__nonzero__(self) -> bool"""
        return _TimeTagger.DoubleVector___nonzero__(self)

    def __bool__(self) -> "bool":
        r"""__bool__(self) -> bool"""
        return _TimeTagger.DoubleVector___bool__(self)

    def __len__(self) -> "std::vector< double >::size_type":
        r"""__len__(self) -> std::vector< double >::size_type"""
        return _TimeTagger.DoubleVector___len__(self)

    def __getslice__(self, i: "std::vector< double >::difference_type", j: "std::vector< double >::difference_type") -> "std::vector< double,std::allocator< double > > *":
        r"""__getslice__(self, i, j) -> DoubleVector"""
        return _TimeTagger.DoubleVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        r"""
        __setslice__(self, i, j)
        __setslice__(self, i, j, v)
        """
        return _TimeTagger.DoubleVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< double >::difference_type", j: "std::vector< double >::difference_type") -> "void":
        r"""__delslice__(self, i, j)"""
        return _TimeTagger.DoubleVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        r"""
        __delitem__(self, i)
        __delitem__(self, slice)
        """
        return _TimeTagger.DoubleVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< double >::value_type const &":
        r"""
        __getitem__(self, slice) -> DoubleVector
        __getitem__(self, i) -> std::vector< double >::value_type const &
        """
        return _TimeTagger.DoubleVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        r"""
        __setitem__(self, slice, v)
        __setitem__(self, slice)
        __setitem__(self, i, x)
        """
        return _TimeTagger.DoubleVector___setitem__(self, *args)

    def pop(self) -> "std::vector< double >::value_type":
        r"""pop(self) -> std::vector< double >::value_type"""
        return _TimeTagger.DoubleVector_pop(self)

    def append(self, x: "std::vector< double >::value_type const &") -> "void":
        r"""append(self, x)"""
        return _TimeTagger.DoubleVector_append(self, x)

    def empty(self) -> "bool":
        r"""empty(self) -> bool"""
        return _TimeTagger.DoubleVector_empty(self)

    def size(self) -> "std::vector< double >::size_type":
        r"""size(self) -> std::vector< double >::size_type"""
        return _TimeTagger.DoubleVector_size(self)

    def swap(self, v: "DoubleVector") -> "void":
        r"""swap(self, v)"""
        return _TimeTagger.DoubleVector_swap(self, v)

    def begin(self) -> "std::vector< double >::iterator":
        r"""begin(self) -> std::vector< double >::iterator"""
        return _TimeTagger.DoubleVector_begin(self)

    def end(self) -> "std::vector< double >::iterator":
        r"""end(self) -> std::vector< double >::iterator"""
        return _TimeTagger.DoubleVector_end(self)

    def rbegin(self) -> "std::vector< double >::reverse_iterator":
        r"""rbegin(self) -> std::vector< double >::reverse_iterator"""
        return _TimeTagger.DoubleVector_rbegin(self)

    def rend(self) -> "std::vector< double >::reverse_iterator":
        r"""rend(self) -> std::vector< double >::reverse_iterator"""
        return _TimeTagger.DoubleVector_rend(self)

    def clear(self) -> "void":
        r"""clear(self)"""
        return _TimeTagger.DoubleVector_clear(self)

    def get_allocator(self) -> "std::vector< double >::allocator_type":
        r"""get_allocator(self) -> std::vector< double >::allocator_type"""
        return _TimeTagger.DoubleVector_get_allocator(self)

    def pop_back(self) -> "void":
        r"""pop_back(self)"""
        return _TimeTagger.DoubleVector_pop_back(self)

    def erase(self, *args) -> "std::vector< double >::iterator":
        r"""
        erase(self, pos) -> std::vector< double >::iterator
        erase(self, first, last) -> std::vector< double >::iterator
        """
        return _TimeTagger.DoubleVector_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(self) -> DoubleVector
        __init__(self, other) -> DoubleVector
        __init__(self, size) -> DoubleVector
        __init__(self, size, value) -> DoubleVector
        """
        _TimeTagger.DoubleVector_swiginit(self, _TimeTagger.new_DoubleVector(*args))

    def push_back(self, x: "std::vector< double >::value_type const &") -> "void":
        r"""push_back(self, x)"""
        return _TimeTagger.DoubleVector_push_back(self, x)

    def front(self) -> "std::vector< double >::value_type const &":
        r"""front(self) -> std::vector< double >::value_type const &"""
        return _TimeTagger.DoubleVector_front(self)

    def back(self) -> "std::vector< double >::value_type const &":
        r"""back(self) -> std::vector< double >::value_type const &"""
        return _TimeTagger.DoubleVector_back(self)

    def assign(self, n: "std::vector< double >::size_type", x: "std::vector< double >::value_type const &") -> "void":
        r"""assign(self, n, x)"""
        return _TimeTagger.DoubleVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        r"""
        resize(self, new_size)
        resize(self, new_size, x)
        """
        return _TimeTagger.DoubleVector_resize(self, *args)

    def insert(self, *args) -> "void":
        r"""
        insert(self, pos, x) -> std::vector< double >::iterator
        insert(self, pos, n, x)
        """
        return _TimeTagger.DoubleVector_insert(self, *args)

    def reserve(self, n: "std::vector< double >::size_type") -> "void":
        r"""reserve(self, n)"""
        return _TimeTagger.DoubleVector_reserve(self, n)

    def capacity(self) -> "std::vector< double >::size_type":
        r"""capacity(self) -> std::vector< double >::size_type"""
        return _TimeTagger.DoubleVector_capacity(self)
    __swig_destroy__ = _TimeTagger.delete_DoubleVector


# Register DoubleVector in _TimeTagger:
_TimeTagger.DoubleVector_swigregister(DoubleVector)


class StringVector(object):
    r"""Proxy of C++ std::vector< std::string > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        r"""iterator(self) -> SwigPyIterator"""
        return _TimeTagger.StringVector_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        r"""__nonzero__(self) -> bool"""
        return _TimeTagger.StringVector___nonzero__(self)

    def __bool__(self) -> "bool":
        r"""__bool__(self) -> bool"""
        return _TimeTagger.StringVector___bool__(self)

    def __len__(self) -> "std::vector< std::string >::size_type":
        r"""__len__(self) -> std::vector< std::string >::size_type"""
        return _TimeTagger.StringVector___len__(self)

    def __getslice__(self, i: "std::vector< std::string >::difference_type", j: "std::vector< std::string >::difference_type") -> "std::vector< std::string,std::allocator< std::string > > *":
        r"""__getslice__(self, i, j) -> StringVector"""
        return _TimeTagger.StringVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        r"""
        __setslice__(self, i, j)
        __setslice__(self, i, j, v)
        """
        return _TimeTagger.StringVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< std::string >::difference_type", j: "std::vector< std::string >::difference_type") -> "void":
        r"""__delslice__(self, i, j)"""
        return _TimeTagger.StringVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        r"""
        __delitem__(self, i)
        __delitem__(self, slice)
        """
        return _TimeTagger.StringVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< std::string >::value_type const &":
        r"""
        __getitem__(self, slice) -> StringVector
        __getitem__(self, i) -> std::vector< std::string >::value_type const &
        """
        return _TimeTagger.StringVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        r"""
        __setitem__(self, slice, v)
        __setitem__(self, slice)
        __setitem__(self, i, x)
        """
        return _TimeTagger.StringVector___setitem__(self, *args)

    def pop(self) -> "std::vector< std::string >::value_type":
        r"""pop(self) -> std::vector< std::string >::value_type"""
        return _TimeTagger.StringVector_pop(self)

    def append(self, x: "std::vector< std::string >::value_type const &") -> "void":
        r"""append(self, x)"""
        return _TimeTagger.StringVector_append(self, x)

    def empty(self) -> "bool":
        r"""empty(self) -> bool"""
        return _TimeTagger.StringVector_empty(self)

    def size(self) -> "std::vector< std::string >::size_type":
        r"""size(self) -> std::vector< std::string >::size_type"""
        return _TimeTagger.StringVector_size(self)

    def swap(self, v: "StringVector") -> "void":
        r"""swap(self, v)"""
        return _TimeTagger.StringVector_swap(self, v)

    def begin(self) -> "std::vector< std::string >::iterator":
        r"""begin(self) -> std::vector< std::string >::iterator"""
        return _TimeTagger.StringVector_begin(self)

    def end(self) -> "std::vector< std::string >::iterator":
        r"""end(self) -> std::vector< std::string >::iterator"""
        return _TimeTagger.StringVector_end(self)

    def rbegin(self) -> "std::vector< std::string >::reverse_iterator":
        r"""rbegin(self) -> std::vector< std::string >::reverse_iterator"""
        return _TimeTagger.StringVector_rbegin(self)

    def rend(self) -> "std::vector< std::string >::reverse_iterator":
        r"""rend(self) -> std::vector< std::string >::reverse_iterator"""
        return _TimeTagger.StringVector_rend(self)

    def clear(self) -> "void":
        r"""clear(self)"""
        return _TimeTagger.StringVector_clear(self)

    def get_allocator(self) -> "std::vector< std::string >::allocator_type":
        r"""get_allocator(self) -> std::vector< std::string >::allocator_type"""
        return _TimeTagger.StringVector_get_allocator(self)

    def pop_back(self) -> "void":
        r"""pop_back(self)"""
        return _TimeTagger.StringVector_pop_back(self)

    def erase(self, *args) -> "std::vector< std::string >::iterator":
        r"""
        erase(self, pos) -> std::vector< std::string >::iterator
        erase(self, first, last) -> std::vector< std::string >::iterator
        """
        return _TimeTagger.StringVector_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(self) -> StringVector
        __init__(self, other) -> StringVector
        __init__(self, size) -> StringVector
        __init__(self, size, value) -> StringVector
        """
        _TimeTagger.StringVector_swiginit(self, _TimeTagger.new_StringVector(*args))

    def push_back(self, x: "std::vector< std::string >::value_type const &") -> "void":
        r"""push_back(self, x)"""
        return _TimeTagger.StringVector_push_back(self, x)

    def front(self) -> "std::vector< std::string >::value_type const &":
        r"""front(self) -> std::vector< std::string >::value_type const &"""
        return _TimeTagger.StringVector_front(self)

    def back(self) -> "std::vector< std::string >::value_type const &":
        r"""back(self) -> std::vector< std::string >::value_type const &"""
        return _TimeTagger.StringVector_back(self)

    def assign(self, n: "std::vector< std::string >::size_type", x: "std::vector< std::string >::value_type const &") -> "void":
        r"""assign(self, n, x)"""
        return _TimeTagger.StringVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        r"""
        resize(self, new_size)
        resize(self, new_size, x)
        """
        return _TimeTagger.StringVector_resize(self, *args)

    def insert(self, *args) -> "void":
        r"""
        insert(self, pos, x) -> std::vector< std::string >::iterator
        insert(self, pos, n, x)
        """
        return _TimeTagger.StringVector_insert(self, *args)

    def reserve(self, n: "std::vector< std::string >::size_type") -> "void":
        r"""reserve(self, n)"""
        return _TimeTagger.StringVector_reserve(self, n)

    def capacity(self) -> "std::vector< std::string >::size_type":
        r"""capacity(self) -> std::vector< std::string >::size_type"""
        return _TimeTagger.StringVector_capacity(self)
    __swig_destroy__ = _TimeTagger.delete_StringVector


# Register StringVector in _TimeTagger:
_TimeTagger.StringVector_swigregister(StringVector)


class StringList(object):
    r"""Proxy of C++ std::list< std::string > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        r"""iterator(self) -> SwigPyIterator"""
        return _TimeTagger.StringList_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        r"""__nonzero__(self) -> bool"""
        return _TimeTagger.StringList___nonzero__(self)

    def __bool__(self) -> "bool":
        r"""__bool__(self) -> bool"""
        return _TimeTagger.StringList___bool__(self)

    def __len__(self) -> "std::list< std::string >::size_type":
        r"""__len__(self) -> std::list< std::string >::size_type"""
        return _TimeTagger.StringList___len__(self)

    def __getslice__(self, i: "std::list< std::string >::difference_type", j: "std::list< std::string >::difference_type") -> "std::list< std::string,std::allocator< std::string > > *":
        r"""__getslice__(self, i, j) -> StringList"""
        return _TimeTagger.StringList___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        r"""
        __setslice__(self, i, j)
        __setslice__(self, i, j, v)
        """
        return _TimeTagger.StringList___setslice__(self, *args)

    def __delslice__(self, i: "std::list< std::string >::difference_type", j: "std::list< std::string >::difference_type") -> "void":
        r"""__delslice__(self, i, j)"""
        return _TimeTagger.StringList___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        r"""
        __delitem__(self, i)
        __delitem__(self, slice)
        """
        return _TimeTagger.StringList___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::list< std::string >::value_type const &":
        r"""
        __getitem__(self, slice) -> StringList
        __getitem__(self, i) -> std::list< std::string >::value_type const &
        """
        return _TimeTagger.StringList___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        r"""
        __setitem__(self, slice, v)
        __setitem__(self, slice)
        __setitem__(self, i, x)
        """
        return _TimeTagger.StringList___setitem__(self, *args)

    def pop(self) -> "std::list< std::string >::value_type":
        r"""pop(self) -> std::list< std::string >::value_type"""
        return _TimeTagger.StringList_pop(self)

    def append(self, x: "std::list< std::string >::value_type const &") -> "void":
        r"""append(self, x)"""
        return _TimeTagger.StringList_append(self, x)

    def empty(self) -> "bool":
        r"""empty(self) -> bool"""
        return _TimeTagger.StringList_empty(self)

    def size(self) -> "std::list< std::string >::size_type":
        r"""size(self) -> std::list< std::string >::size_type"""
        return _TimeTagger.StringList_size(self)

    def swap(self, v: "StringList") -> "void":
        r"""swap(self, v)"""
        return _TimeTagger.StringList_swap(self, v)

    def begin(self) -> "std::list< std::string >::iterator":
        r"""begin(self) -> std::list< std::string >::iterator"""
        return _TimeTagger.StringList_begin(self)

    def end(self) -> "std::list< std::string >::iterator":
        r"""end(self) -> std::list< std::string >::iterator"""
        return _TimeTagger.StringList_end(self)

    def rbegin(self) -> "std::list< std::string >::reverse_iterator":
        r"""rbegin(self) -> std::list< std::string >::reverse_iterator"""
        return _TimeTagger.StringList_rbegin(self)

    def rend(self) -> "std::list< std::string >::reverse_iterator":
        r"""rend(self) -> std::list< std::string >::reverse_iterator"""
        return _TimeTagger.StringList_rend(self)

    def clear(self) -> "void":
        r"""clear(self)"""
        return _TimeTagger.StringList_clear(self)

    def get_allocator(self) -> "std::list< std::string >::allocator_type":
        r"""get_allocator(self) -> std::list< std::string >::allocator_type"""
        return _TimeTagger.StringList_get_allocator(self)

    def pop_back(self) -> "void":
        r"""pop_back(self)"""
        return _TimeTagger.StringList_pop_back(self)

    def erase(self, *args) -> "std::list< std::string >::iterator":
        r"""
        erase(self, pos) -> std::list< std::string >::iterator
        erase(self, first, last) -> std::list< std::string >::iterator
        """
        return _TimeTagger.StringList_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(self) -> StringList
        __init__(self, other) -> StringList
        __init__(self, size) -> StringList
        __init__(self, size, value) -> StringList
        """
        _TimeTagger.StringList_swiginit(self, _TimeTagger.new_StringList(*args))

    def push_back(self, x: "std::list< std::string >::value_type const &") -> "void":
        r"""push_back(self, x)"""
        return _TimeTagger.StringList_push_back(self, x)

    def front(self) -> "std::list< std::string >::value_type const &":
        r"""front(self) -> std::list< std::string >::value_type const &"""
        return _TimeTagger.StringList_front(self)

    def back(self) -> "std::list< std::string >::value_type const &":
        r"""back(self) -> std::list< std::string >::value_type const &"""
        return _TimeTagger.StringList_back(self)

    def assign(self, n: "std::list< std::string >::size_type", x: "std::list< std::string >::value_type const &") -> "void":
        r"""assign(self, n, x)"""
        return _TimeTagger.StringList_assign(self, n, x)

    def resize(self, *args) -> "void":
        r"""
        resize(self, new_size)
        resize(self, new_size, x)
        """
        return _TimeTagger.StringList_resize(self, *args)

    def insert(self, *args) -> "void":
        r"""
        insert(self, pos, x) -> std::list< std::string >::iterator
        insert(self, pos, n, x)
        """
        return _TimeTagger.StringList_insert(self, *args)

    def pop_front(self) -> "void":
        r"""pop_front(self)"""
        return _TimeTagger.StringList_pop_front(self)

    def push_front(self, x: "std::list< std::string >::value_type const &") -> "void":
        r"""push_front(self, x)"""
        return _TimeTagger.StringList_push_front(self, x)

    def reverse(self) -> "void":
        r"""reverse(self)"""
        return _TimeTagger.StringList_reverse(self)
    __swig_destroy__ = _TimeTagger.delete_StringList


# Register StringList in _TimeTagger:
_TimeTagger.StringList_swigregister(StringList)


class EventVector(object):
    r"""Proxy of C++ std::vector< Event > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        r"""iterator(self) -> SwigPyIterator"""
        return _TimeTagger.EventVector_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        r"""__nonzero__(self) -> bool"""
        return _TimeTagger.EventVector___nonzero__(self)

    def __bool__(self) -> "bool":
        r"""__bool__(self) -> bool"""
        return _TimeTagger.EventVector___bool__(self)

    def __len__(self) -> "std::vector< Event >::size_type":
        r"""__len__(self) -> std::vector< Event >::size_type"""
        return _TimeTagger.EventVector___len__(self)

    def __getslice__(self, i: "std::vector< Event >::difference_type", j: "std::vector< Event >::difference_type") -> "std::vector< Event,std::allocator< Event > > *":
        r"""__getslice__(self, i, j) -> EventVector"""
        return _TimeTagger.EventVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        r"""
        __setslice__(self, i, j)
        __setslice__(self, i, j, v)
        """
        return _TimeTagger.EventVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< Event >::difference_type", j: "std::vector< Event >::difference_type") -> "void":
        r"""__delslice__(self, i, j)"""
        return _TimeTagger.EventVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        r"""
        __delitem__(self, i)
        __delitem__(self, slice)
        """
        return _TimeTagger.EventVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< Event >::value_type const &":
        r"""
        __getitem__(self, slice) -> EventVector
        __getitem__(self, i) -> Event
        """
        return _TimeTagger.EventVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        r"""
        __setitem__(self, slice, v)
        __setitem__(self, slice)
        __setitem__(self, i, x)
        """
        return _TimeTagger.EventVector___setitem__(self, *args)

    def pop(self) -> "std::vector< Event >::value_type":
        r"""pop(self) -> Event"""
        return _TimeTagger.EventVector_pop(self)

    def append(self, x: "Event") -> "void":
        r"""append(self, x)"""
        return _TimeTagger.EventVector_append(self, x)

    def empty(self) -> "bool":
        r"""empty(self) -> bool"""
        return _TimeTagger.EventVector_empty(self)

    def size(self) -> "std::vector< Event >::size_type":
        r"""size(self) -> std::vector< Event >::size_type"""
        return _TimeTagger.EventVector_size(self)

    def swap(self, v: "EventVector") -> "void":
        r"""swap(self, v)"""
        return _TimeTagger.EventVector_swap(self, v)

    def begin(self) -> "std::vector< Event >::iterator":
        r"""begin(self) -> std::vector< Event >::iterator"""
        return _TimeTagger.EventVector_begin(self)

    def end(self) -> "std::vector< Event >::iterator":
        r"""end(self) -> std::vector< Event >::iterator"""
        return _TimeTagger.EventVector_end(self)

    def rbegin(self) -> "std::vector< Event >::reverse_iterator":
        r"""rbegin(self) -> std::vector< Event >::reverse_iterator"""
        return _TimeTagger.EventVector_rbegin(self)

    def rend(self) -> "std::vector< Event >::reverse_iterator":
        r"""rend(self) -> std::vector< Event >::reverse_iterator"""
        return _TimeTagger.EventVector_rend(self)

    def clear(self) -> "void":
        r"""clear(self)"""
        return _TimeTagger.EventVector_clear(self)

    def get_allocator(self) -> "std::vector< Event >::allocator_type":
        r"""get_allocator(self) -> std::vector< Event >::allocator_type"""
        return _TimeTagger.EventVector_get_allocator(self)

    def pop_back(self) -> "void":
        r"""pop_back(self)"""
        return _TimeTagger.EventVector_pop_back(self)

    def erase(self, *args) -> "std::vector< Event >::iterator":
        r"""
        erase(self, pos) -> std::vector< Event >::iterator
        erase(self, first, last) -> std::vector< Event >::iterator
        """
        return _TimeTagger.EventVector_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(self) -> EventVector
        __init__(self, other) -> EventVector
        __init__(self, size) -> EventVector
        __init__(self, size, value) -> EventVector
        """
        _TimeTagger.EventVector_swiginit(self, _TimeTagger.new_EventVector(*args))

    def push_back(self, x: "Event") -> "void":
        r"""push_back(self, x)"""
        return _TimeTagger.EventVector_push_back(self, x)

    def front(self) -> "std::vector< Event >::value_type const &":
        r"""front(self) -> Event"""
        return _TimeTagger.EventVector_front(self)

    def back(self) -> "std::vector< Event >::value_type const &":
        r"""back(self) -> Event"""
        return _TimeTagger.EventVector_back(self)

    def assign(self, n: "std::vector< Event >::size_type", x: "Event") -> "void":
        r"""assign(self, n, x)"""
        return _TimeTagger.EventVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        r"""
        resize(self, new_size)
        resize(self, new_size, x)
        """
        return _TimeTagger.EventVector_resize(self, *args)

    def insert(self, *args) -> "void":
        r"""
        insert(self, pos, x) -> std::vector< Event >::iterator
        insert(self, pos, n, x)
        """
        return _TimeTagger.EventVector_insert(self, *args)

    def reserve(self, n: "std::vector< Event >::size_type") -> "void":
        r"""reserve(self, n)"""
        return _TimeTagger.EventVector_reserve(self, n)

    def capacity(self) -> "std::vector< Event >::size_type":
        r"""capacity(self) -> std::vector< Event >::size_type"""
        return _TimeTagger.EventVector_capacity(self)
    __swig_destroy__ = _TimeTagger.delete_EventVector


# Register EventVector in _TimeTagger:
_TimeTagger.EventVector_swigregister(EventVector)


class EventVectorVector(object):
    r"""Proxy of C++ std::vector< std::vector< Event > > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        r"""iterator(self) -> SwigPyIterator"""
        return _TimeTagger.EventVectorVector_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        r"""__nonzero__(self) -> bool"""
        return _TimeTagger.EventVectorVector___nonzero__(self)

    def __bool__(self) -> "bool":
        r"""__bool__(self) -> bool"""
        return _TimeTagger.EventVectorVector___bool__(self)

    def __len__(self) -> "std::vector< std::vector< Event > >::size_type":
        r"""__len__(self) -> std::vector< std::vector< Event > >::size_type"""
        return _TimeTagger.EventVectorVector___len__(self)

    def __getslice__(self, i: "std::vector< std::vector< Event > >::difference_type", j: "std::vector< std::vector< Event > >::difference_type") -> "std::vector< std::vector< Event,std::allocator< Event > >,std::allocator< std::vector< Event,std::allocator< Event > > > > *":
        r"""__getslice__(self, i, j) -> EventVectorVector"""
        return _TimeTagger.EventVectorVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        r"""
        __setslice__(self, i, j)
        __setslice__(self, i, j, v)
        """
        return _TimeTagger.EventVectorVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< std::vector< Event > >::difference_type", j: "std::vector< std::vector< Event > >::difference_type") -> "void":
        r"""__delslice__(self, i, j)"""
        return _TimeTagger.EventVectorVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        r"""
        __delitem__(self, i)
        __delitem__(self, slice)
        """
        return _TimeTagger.EventVectorVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< std::vector< Event > >::value_type const &":
        r"""
        __getitem__(self, slice) -> EventVectorVector
        __getitem__(self, i) -> EventVector
        """
        return _TimeTagger.EventVectorVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        r"""
        __setitem__(self, slice, v)
        __setitem__(self, slice)
        __setitem__(self, i, x)
        """
        return _TimeTagger.EventVectorVector___setitem__(self, *args)

    def pop(self) -> "std::vector< std::vector< Event > >::value_type":
        r"""pop(self) -> EventVector"""
        return _TimeTagger.EventVectorVector_pop(self)

    def append(self, x: "EventVector") -> "void":
        r"""append(self, x)"""
        return _TimeTagger.EventVectorVector_append(self, x)

    def empty(self) -> "bool":
        r"""empty(self) -> bool"""
        return _TimeTagger.EventVectorVector_empty(self)

    def size(self) -> "std::vector< std::vector< Event > >::size_type":
        r"""size(self) -> std::vector< std::vector< Event > >::size_type"""
        return _TimeTagger.EventVectorVector_size(self)

    def swap(self, v: "EventVectorVector") -> "void":
        r"""swap(self, v)"""
        return _TimeTagger.EventVectorVector_swap(self, v)

    def begin(self) -> "std::vector< std::vector< Event > >::iterator":
        r"""begin(self) -> std::vector< std::vector< Event > >::iterator"""
        return _TimeTagger.EventVectorVector_begin(self)

    def end(self) -> "std::vector< std::vector< Event > >::iterator":
        r"""end(self) -> std::vector< std::vector< Event > >::iterator"""
        return _TimeTagger.EventVectorVector_end(self)

    def rbegin(self) -> "std::vector< std::vector< Event > >::reverse_iterator":
        r"""rbegin(self) -> std::vector< std::vector< Event > >::reverse_iterator"""
        return _TimeTagger.EventVectorVector_rbegin(self)

    def rend(self) -> "std::vector< std::vector< Event > >::reverse_iterator":
        r"""rend(self) -> std::vector< std::vector< Event > >::reverse_iterator"""
        return _TimeTagger.EventVectorVector_rend(self)

    def clear(self) -> "void":
        r"""clear(self)"""
        return _TimeTagger.EventVectorVector_clear(self)

    def get_allocator(self) -> "std::vector< std::vector< Event > >::allocator_type":
        r"""get_allocator(self) -> std::vector< std::vector< Event > >::allocator_type"""
        return _TimeTagger.EventVectorVector_get_allocator(self)

    def pop_back(self) -> "void":
        r"""pop_back(self)"""
        return _TimeTagger.EventVectorVector_pop_back(self)

    def erase(self, *args) -> "std::vector< std::vector< Event > >::iterator":
        r"""
        erase(self, pos) -> std::vector< std::vector< Event > >::iterator
        erase(self, first, last) -> std::vector< std::vector< Event > >::iterator
        """
        return _TimeTagger.EventVectorVector_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(self) -> EventVectorVector
        __init__(self, other) -> EventVectorVector
        __init__(self, size) -> EventVectorVector
        __init__(self, size, value) -> EventVectorVector
        """
        _TimeTagger.EventVectorVector_swiginit(self, _TimeTagger.new_EventVectorVector(*args))

    def push_back(self, x: "EventVector") -> "void":
        r"""push_back(self, x)"""
        return _TimeTagger.EventVectorVector_push_back(self, x)

    def front(self) -> "std::vector< std::vector< Event > >::value_type const &":
        r"""front(self) -> EventVector"""
        return _TimeTagger.EventVectorVector_front(self)

    def back(self) -> "std::vector< std::vector< Event > >::value_type const &":
        r"""back(self) -> EventVector"""
        return _TimeTagger.EventVectorVector_back(self)

    def assign(self, n: "std::vector< std::vector< Event > >::size_type", x: "EventVector") -> "void":
        r"""assign(self, n, x)"""
        return _TimeTagger.EventVectorVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        r"""
        resize(self, new_size)
        resize(self, new_size, x)
        """
        return _TimeTagger.EventVectorVector_resize(self, *args)

    def insert(self, *args) -> "void":
        r"""
        insert(self, pos, x) -> std::vector< std::vector< Event > >::iterator
        insert(self, pos, n, x)
        """
        return _TimeTagger.EventVectorVector_insert(self, *args)

    def reserve(self, n: "std::vector< std::vector< Event > >::size_type") -> "void":
        r"""reserve(self, n)"""
        return _TimeTagger.EventVectorVector_reserve(self, n)

    def capacity(self) -> "std::vector< std::vector< Event > >::size_type":
        r"""capacity(self) -> std::vector< std::vector< Event > >::size_type"""
        return _TimeTagger.EventVectorVector_capacity(self)
    __swig_destroy__ = _TimeTagger.delete_EventVectorVector


# Register EventVectorVector in _TimeTagger:
_TimeTagger.EventVectorVector_swigregister(EventVectorVector)


class IntVectorVector(object):
    r"""Proxy of C++ std::vector< std::vector< int > > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        r"""iterator(self) -> SwigPyIterator"""
        return _TimeTagger.IntVectorVector_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        r"""__nonzero__(self) -> bool"""
        return _TimeTagger.IntVectorVector___nonzero__(self)

    def __bool__(self) -> "bool":
        r"""__bool__(self) -> bool"""
        return _TimeTagger.IntVectorVector___bool__(self)

    def __len__(self) -> "std::vector< std::vector< int > >::size_type":
        r"""__len__(self) -> std::vector< std::vector< int > >::size_type"""
        return _TimeTagger.IntVectorVector___len__(self)

    def __getslice__(self, i: "std::vector< std::vector< int > >::difference_type", j: "std::vector< std::vector< int > >::difference_type") -> "std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > *":
        r"""__getslice__(self, i, j) -> IntVectorVector"""
        return _TimeTagger.IntVectorVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        r"""
        __setslice__(self, i, j)
        __setslice__(self, i, j, v)
        """
        return _TimeTagger.IntVectorVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< std::vector< int > >::difference_type", j: "std::vector< std::vector< int > >::difference_type") -> "void":
        r"""__delslice__(self, i, j)"""
        return _TimeTagger.IntVectorVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        r"""
        __delitem__(self, i)
        __delitem__(self, slice)
        """
        return _TimeTagger.IntVectorVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< std::vector< int > >::value_type const &":
        r"""
        __getitem__(self, slice) -> IntVectorVector
        __getitem__(self, i) -> IntVector
        """
        return _TimeTagger.IntVectorVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        r"""
        __setitem__(self, slice, v)
        __setitem__(self, slice)
        __setitem__(self, i, x)
        """
        return _TimeTagger.IntVectorVector___setitem__(self, *args)

    def pop(self) -> "std::vector< std::vector< int > >::value_type":
        r"""pop(self) -> IntVector"""
        return _TimeTagger.IntVectorVector_pop(self)

    def append(self, x: "IntVector") -> "void":
        r"""append(self, x)"""
        return _TimeTagger.IntVectorVector_append(self, x)

    def empty(self) -> "bool":
        r"""empty(self) -> bool"""
        return _TimeTagger.IntVectorVector_empty(self)

    def size(self) -> "std::vector< std::vector< int > >::size_type":
        r"""size(self) -> std::vector< std::vector< int > >::size_type"""
        return _TimeTagger.IntVectorVector_size(self)

    def swap(self, v: "IntVectorVector") -> "void":
        r"""swap(self, v)"""
        return _TimeTagger.IntVectorVector_swap(self, v)

    def begin(self) -> "std::vector< std::vector< int > >::iterator":
        r"""begin(self) -> std::vector< std::vector< int > >::iterator"""
        return _TimeTagger.IntVectorVector_begin(self)

    def end(self) -> "std::vector< std::vector< int > >::iterator":
        r"""end(self) -> std::vector< std::vector< int > >::iterator"""
        return _TimeTagger.IntVectorVector_end(self)

    def rbegin(self) -> "std::vector< std::vector< int > >::reverse_iterator":
        r"""rbegin(self) -> std::vector< std::vector< int > >::reverse_iterator"""
        return _TimeTagger.IntVectorVector_rbegin(self)

    def rend(self) -> "std::vector< std::vector< int > >::reverse_iterator":
        r"""rend(self) -> std::vector< std::vector< int > >::reverse_iterator"""
        return _TimeTagger.IntVectorVector_rend(self)

    def clear(self) -> "void":
        r"""clear(self)"""
        return _TimeTagger.IntVectorVector_clear(self)

    def get_allocator(self) -> "std::vector< std::vector< int > >::allocator_type":
        r"""get_allocator(self) -> std::vector< std::vector< int > >::allocator_type"""
        return _TimeTagger.IntVectorVector_get_allocator(self)

    def pop_back(self) -> "void":
        r"""pop_back(self)"""
        return _TimeTagger.IntVectorVector_pop_back(self)

    def erase(self, *args) -> "std::vector< std::vector< int > >::iterator":
        r"""
        erase(self, pos) -> std::vector< std::vector< int > >::iterator
        erase(self, first, last) -> std::vector< std::vector< int > >::iterator
        """
        return _TimeTagger.IntVectorVector_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(self) -> IntVectorVector
        __init__(self, other) -> IntVectorVector
        __init__(self, size) -> IntVectorVector
        __init__(self, size, value) -> IntVectorVector
        """
        _TimeTagger.IntVectorVector_swiginit(self, _TimeTagger.new_IntVectorVector(*args))

    def push_back(self, x: "IntVector") -> "void":
        r"""push_back(self, x)"""
        return _TimeTagger.IntVectorVector_push_back(self, x)

    def front(self) -> "std::vector< std::vector< int > >::value_type const &":
        r"""front(self) -> IntVector"""
        return _TimeTagger.IntVectorVector_front(self)

    def back(self) -> "std::vector< std::vector< int > >::value_type const &":
        r"""back(self) -> IntVector"""
        return _TimeTagger.IntVectorVector_back(self)

    def assign(self, n: "std::vector< std::vector< int > >::size_type", x: "IntVector") -> "void":
        r"""assign(self, n, x)"""
        return _TimeTagger.IntVectorVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        r"""
        resize(self, new_size)
        resize(self, new_size, x)
        """
        return _TimeTagger.IntVectorVector_resize(self, *args)

    def insert(self, *args) -> "void":
        r"""
        insert(self, pos, x) -> std::vector< std::vector< int > >::iterator
        insert(self, pos, n, x)
        """
        return _TimeTagger.IntVectorVector_insert(self, *args)

    def reserve(self, n: "std::vector< std::vector< int > >::size_type") -> "void":
        r"""reserve(self, n)"""
        return _TimeTagger.IntVectorVector_reserve(self, n)

    def capacity(self) -> "std::vector< std::vector< int > >::size_type":
        r"""capacity(self) -> std::vector< std::vector< int > >::size_type"""
        return _TimeTagger.IntVectorVector_capacity(self)
    __swig_destroy__ = _TimeTagger.delete_IntVectorVector


# Register IntVectorVector in _TimeTagger:
_TimeTagger.IntVectorVector_swigregister(IntVectorVector)


class UIntVectorVector(object):
    r"""Proxy of C++ std::vector< std::vector< unsigned int > > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        r"""iterator(self) -> SwigPyIterator"""
        return _TimeTagger.UIntVectorVector_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        r"""__nonzero__(self) -> bool"""
        return _TimeTagger.UIntVectorVector___nonzero__(self)

    def __bool__(self) -> "bool":
        r"""__bool__(self) -> bool"""
        return _TimeTagger.UIntVectorVector___bool__(self)

    def __len__(self) -> "std::vector< std::vector< unsigned int > >::size_type":
        r"""__len__(self) -> std::vector< std::vector< unsigned int > >::size_type"""
        return _TimeTagger.UIntVectorVector___len__(self)

    def __getslice__(self, i: "std::vector< std::vector< unsigned int > >::difference_type", j: "std::vector< std::vector< unsigned int > >::difference_type") -> "std::vector< std::vector< unsigned int,std::allocator< unsigned int > >,std::allocator< std::vector< unsigned int,std::allocator< unsigned int > > > > *":
        r"""__getslice__(self, i, j) -> UIntVectorVector"""
        return _TimeTagger.UIntVectorVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        r"""
        __setslice__(self, i, j)
        __setslice__(self, i, j, v)
        """
        return _TimeTagger.UIntVectorVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< std::vector< unsigned int > >::difference_type", j: "std::vector< std::vector< unsigned int > >::difference_type") -> "void":
        r"""__delslice__(self, i, j)"""
        return _TimeTagger.UIntVectorVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        r"""
        __delitem__(self, i)
        __delitem__(self, slice)
        """
        return _TimeTagger.UIntVectorVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< std::vector< unsigned int > >::value_type const &":
        r"""
        __getitem__(self, slice) -> UIntVectorVector
        __getitem__(self, i) -> UIntVector
        """
        return _TimeTagger.UIntVectorVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        r"""
        __setitem__(self, slice, v)
        __setitem__(self, slice)
        __setitem__(self, i, x)
        """
        return _TimeTagger.UIntVectorVector___setitem__(self, *args)

    def pop(self) -> "std::vector< std::vector< unsigned int > >::value_type":
        r"""pop(self) -> UIntVector"""
        return _TimeTagger.UIntVectorVector_pop(self)

    def append(self, x: "UIntVector") -> "void":
        r"""append(self, x)"""
        return _TimeTagger.UIntVectorVector_append(self, x)

    def empty(self) -> "bool":
        r"""empty(self) -> bool"""
        return _TimeTagger.UIntVectorVector_empty(self)

    def size(self) -> "std::vector< std::vector< unsigned int > >::size_type":
        r"""size(self) -> std::vector< std::vector< unsigned int > >::size_type"""
        return _TimeTagger.UIntVectorVector_size(self)

    def swap(self, v: "UIntVectorVector") -> "void":
        r"""swap(self, v)"""
        return _TimeTagger.UIntVectorVector_swap(self, v)

    def begin(self) -> "std::vector< std::vector< unsigned int > >::iterator":
        r"""begin(self) -> std::vector< std::vector< unsigned int > >::iterator"""
        return _TimeTagger.UIntVectorVector_begin(self)

    def end(self) -> "std::vector< std::vector< unsigned int > >::iterator":
        r"""end(self) -> std::vector< std::vector< unsigned int > >::iterator"""
        return _TimeTagger.UIntVectorVector_end(self)

    def rbegin(self) -> "std::vector< std::vector< unsigned int > >::reverse_iterator":
        r"""rbegin(self) -> std::vector< std::vector< unsigned int > >::reverse_iterator"""
        return _TimeTagger.UIntVectorVector_rbegin(self)

    def rend(self) -> "std::vector< std::vector< unsigned int > >::reverse_iterator":
        r"""rend(self) -> std::vector< std::vector< unsigned int > >::reverse_iterator"""
        return _TimeTagger.UIntVectorVector_rend(self)

    def clear(self) -> "void":
        r"""clear(self)"""
        return _TimeTagger.UIntVectorVector_clear(self)

    def get_allocator(self) -> "std::vector< std::vector< unsigned int > >::allocator_type":
        r"""get_allocator(self) -> std::vector< std::vector< unsigned int > >::allocator_type"""
        return _TimeTagger.UIntVectorVector_get_allocator(self)

    def pop_back(self) -> "void":
        r"""pop_back(self)"""
        return _TimeTagger.UIntVectorVector_pop_back(self)

    def erase(self, *args) -> "std::vector< std::vector< unsigned int > >::iterator":
        r"""
        erase(self, pos) -> std::vector< std::vector< unsigned int > >::iterator
        erase(self, first, last) -> std::vector< std::vector< unsigned int > >::iterator
        """
        return _TimeTagger.UIntVectorVector_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(self) -> UIntVectorVector
        __init__(self, other) -> UIntVectorVector
        __init__(self, size) -> UIntVectorVector
        __init__(self, size, value) -> UIntVectorVector
        """
        _TimeTagger.UIntVectorVector_swiginit(self, _TimeTagger.new_UIntVectorVector(*args))

    def push_back(self, x: "UIntVector") -> "void":
        r"""push_back(self, x)"""
        return _TimeTagger.UIntVectorVector_push_back(self, x)

    def front(self) -> "std::vector< std::vector< unsigned int > >::value_type const &":
        r"""front(self) -> UIntVector"""
        return _TimeTagger.UIntVectorVector_front(self)

    def back(self) -> "std::vector< std::vector< unsigned int > >::value_type const &":
        r"""back(self) -> UIntVector"""
        return _TimeTagger.UIntVectorVector_back(self)

    def assign(self, n: "std::vector< std::vector< unsigned int > >::size_type", x: "UIntVector") -> "void":
        r"""assign(self, n, x)"""
        return _TimeTagger.UIntVectorVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        r"""
        resize(self, new_size)
        resize(self, new_size, x)
        """
        return _TimeTagger.UIntVectorVector_resize(self, *args)

    def insert(self, *args) -> "void":
        r"""
        insert(self, pos, x) -> std::vector< std::vector< unsigned int > >::iterator
        insert(self, pos, n, x)
        """
        return _TimeTagger.UIntVectorVector_insert(self, *args)

    def reserve(self, n: "std::vector< std::vector< unsigned int > >::size_type") -> "void":
        r"""reserve(self, n)"""
        return _TimeTagger.UIntVectorVector_reserve(self, n)

    def capacity(self) -> "std::vector< std::vector< unsigned int > >::size_type":
        r"""capacity(self) -> std::vector< std::vector< unsigned int > >::size_type"""
        return _TimeTagger.UIntVectorVector_capacity(self)
    __swig_destroy__ = _TimeTagger.delete_UIntVectorVector


# Register UIntVectorVector in _TimeTagger:
_TimeTagger.UIntVectorVector_swigregister(UIntVectorVector)


def getVersion() -> "std::string":
    r"""getVersion() -> std::string"""
    return _TimeTagger.getVersion()


Resolution_Standard = _TimeTagger.Resolution_Standard

Resolution_HighResA = _TimeTagger.Resolution_HighResA

Resolution_HighResB = _TimeTagger.Resolution_HighResB

Resolution_HighResC = _TimeTagger.Resolution_HighResC

ChannelEdge_All = _TimeTagger.ChannelEdge_All

ChannelEdge_Rising = _TimeTagger.ChannelEdge_Rising

ChannelEdge_Falling = _TimeTagger.ChannelEdge_Falling

ChannelEdge_HighResAll = _TimeTagger.ChannelEdge_HighResAll

ChannelEdge_HighResRising = _TimeTagger.ChannelEdge_HighResRising

ChannelEdge_HighResFalling = _TimeTagger.ChannelEdge_HighResFalling

ChannelEdge_StandardAll = _TimeTagger.ChannelEdge_StandardAll

ChannelEdge_StandardRising = _TimeTagger.ChannelEdge_StandardRising

ChannelEdge_StandardFalling = _TimeTagger.ChannelEdge_StandardFalling


class SoftwareClockState(object):
    r"""Proxy of C++ SoftwareClockState class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    clock_period = property(_TimeTagger.SoftwareClockState_clock_period_get, _TimeTagger.SoftwareClockState_clock_period_set, doc=r"""clock_period""")
    input_channel = property(_TimeTagger.SoftwareClockState_input_channel_get, _TimeTagger.SoftwareClockState_input_channel_set, doc=r"""input_channel""")
    ideal_clock_channel = property(_TimeTagger.SoftwareClockState_ideal_clock_channel_get, _TimeTagger.SoftwareClockState_ideal_clock_channel_set, doc=r"""ideal_clock_channel""")
    averaging_periods = property(_TimeTagger.SoftwareClockState_averaging_periods_get, _TimeTagger.SoftwareClockState_averaging_periods_set, doc=r"""averaging_periods""")
    enabled = property(_TimeTagger.SoftwareClockState_enabled_get, _TimeTagger.SoftwareClockState_enabled_set, doc=r"""enabled""")
    is_locked = property(_TimeTagger.SoftwareClockState_is_locked_get, _TimeTagger.SoftwareClockState_is_locked_set, doc=r"""is_locked""")
    error_counter = property(_TimeTagger.SoftwareClockState_error_counter_get, _TimeTagger.SoftwareClockState_error_counter_set, doc=r"""error_counter""")
    last_ideal_clock_event = property(_TimeTagger.SoftwareClockState_last_ideal_clock_event_get, _TimeTagger.SoftwareClockState_last_ideal_clock_event_set, doc=r"""last_ideal_clock_event""")
    period_error = property(_TimeTagger.SoftwareClockState_period_error_get, _TimeTagger.SoftwareClockState_period_error_set, doc=r"""period_error""")
    phase_error_estimation = property(_TimeTagger.SoftwareClockState_phase_error_estimation_get, _TimeTagger.SoftwareClockState_phase_error_estimation_set, doc=r"""phase_error_estimation""")

    def __init__(self):
        r"""__init__(self) -> SoftwareClockState"""
        _TimeTagger.SoftwareClockState_swiginit(self, _TimeTagger.new_SoftwareClockState())
    __swig_destroy__ = _TimeTagger.delete_SoftwareClockState


# Register SoftwareClockState in _TimeTagger:
_TimeTagger.SoftwareClockState_swigregister(SoftwareClockState)
cvar = _TimeTagger.cvar
CHANNEL_UNUSED = cvar.CHANNEL_UNUSED
CHANNEL_UNUSED_OLD = cvar.CHANNEL_UNUSED_OLD
TT_CHANNEL_NUMBER_SCHEME_AUTO = cvar.TT_CHANNEL_NUMBER_SCHEME_AUTO
TT_CHANNEL_NUMBER_SCHEME_ZERO = cvar.TT_CHANNEL_NUMBER_SCHEME_ZERO
TT_CHANNEL_NUMBER_SCHEME_ONE = cvar.TT_CHANNEL_NUMBER_SCHEME_ONE
TT_CHANNEL_RISING_AND_FALLING_EDGES = cvar.TT_CHANNEL_RISING_AND_FALLING_EDGES
TT_CHANNEL_RISING_EDGES = cvar.TT_CHANNEL_RISING_EDGES
TT_CHANNEL_FALLING_EDGES = cvar.TT_CHANNEL_FALLING_EDGES

FpgaLinkInterface_SFPP_10GE = _TimeTagger.FpgaLinkInterface_SFPP_10GE


def createTimeTagger(*args, **kwargs) -> "TimeTagger":
    r"""createTimeTagger(serial="", resolution=Standard) -> TimeTagger"""
    return _TimeTagger.createTimeTagger(*args, **kwargs)


def createTimeTaggerVirtual() -> "TimeTaggerVirtual":
    r"""createTimeTaggerVirtual() -> TimeTaggerVirtual"""
    return _TimeTagger.createTimeTaggerVirtual()


def createTimeTaggerNetwork(*args, **kwargs) -> "TimeTaggerNetwork":
    r"""createTimeTaggerNetwork(address="localhost:41101") -> TimeTaggerNetwork"""
    return _TimeTagger.createTimeTaggerNetwork(*args, **kwargs)


def setCustomBitFileName(bitFileName: "std::string const &") -> "void":
    r"""setCustomBitFileName(bitFileName)"""
    return _TimeTagger.setCustomBitFileName(bitFileName)


def scanTimeTagger() -> "std::vector< std::string,std::allocator< std::string > >":
    r"""scanTimeTagger() -> StringVector"""
    return _TimeTagger.scanTimeTagger()


def __getTimeTaggerServerInfo(*args, **kwargs) -> "std::string":
    r"""__getTimeTaggerServerInfo(address="localhost:41101") -> std::string"""
    return _TimeTagger.__getTimeTaggerServerInfo(*args, **kwargs)


def scanTimeTaggerServers() -> "std::vector< std::string,std::allocator< std::string > >":
    r"""scanTimeTaggerServers() -> StringVector"""
    return _TimeTagger.scanTimeTaggerServers()


def getTimeTaggerModel(serial: "std::string const &") -> "std::string":
    r"""getTimeTaggerModel(serial) -> std::string"""
    return _TimeTagger.getTimeTaggerModel(serial)


def setTimeTaggerChannelNumberScheme(scheme: "int") -> "void":
    r"""setTimeTaggerChannelNumberScheme(scheme)"""
    return _TimeTagger.setTimeTaggerChannelNumberScheme(scheme)


def getTimeTaggerChannelNumberScheme() -> "int":
    r"""getTimeTaggerChannelNumberScheme() -> int"""
    return _TimeTagger.getTimeTaggerChannelNumberScheme()


def hasTimeTaggerVirtualLicense() -> "bool":
    r"""hasTimeTaggerVirtualLicense() -> bool"""
    return _TimeTagger.hasTimeTaggerVirtualLicense()


def flashLicense(serial: "std::string const &", license: "std::string const &") -> "void":
    r"""flashLicense(serial, license)"""
    return _TimeTagger.flashLicense(serial, license)


def __extractDeviceLicense(license: "std::string const &") -> "std::string":
    r"""__extractDeviceLicense(license) -> std::string"""
    return _TimeTagger.__extractDeviceLicense(license)


LOGGER_ERROR = _TimeTagger.LOGGER_ERROR

LOGGER_WARNING = _TimeTagger.LOGGER_WARNING

LOGGER_INFO = _TimeTagger.LOGGER_INFO


class CustomLogger(object):
    r"""Proxy of C++ CustomLogger class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""__init__(self) -> CustomLogger"""
        if self.__class__ == CustomLogger:
            _self = None
        else:
            _self = self
        _TimeTagger.CustomLogger_swiginit(self, _TimeTagger.new_CustomLogger(_self, ))
    __swig_destroy__ = _TimeTagger.delete_CustomLogger

    def enable(self) -> "void":
        r"""enable(self)"""
        return _TimeTagger.CustomLogger_enable(self)

    def disable(self) -> "void":
        r"""disable(self)"""
        return _TimeTagger.CustomLogger_disable(self)

    def Log(self, level: "int", msg: "std::string const &") -> "void":
        r"""Log(self, level, msg)"""
        return _TimeTagger.CustomLogger_Log(self, level, msg)

    def __disown__(self):
        self.this.disown()
        _TimeTagger.disown_CustomLogger(self)
        return weakref.proxy(self)


# Register CustomLogger in _TimeTagger:
_TimeTagger.CustomLogger_swigregister(CustomLogger)


class TimeTaggerBase(object):
    r"""Proxy of C++ TimeTaggerBase class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def getFence(self, alloc_fence: "bool" = True) -> "unsigned int":
        r"""getFence(self, alloc_fence=True) -> unsigned int"""
        return _TimeTagger.TimeTaggerBase_getFence(self, alloc_fence)

    def __waitForFence(self, fence: "unsigned int", timeout: "int64_t" = -1) -> "bool":
        r"""__waitForFence(self, fence, timeout=-1) -> bool"""
        return _TimeTagger.TimeTaggerBase___waitForFence(self, fence, timeout)

    def __sync(self, timeout: "int64_t" = -1) -> "bool":
        r"""__sync(self, timeout=-1) -> bool"""
        return _TimeTagger.TimeTaggerBase___sync(self, timeout)

    def getInvertedChannel(self, channel: "int") -> "int":
        r"""getInvertedChannel(self, channel) -> int"""
        return _TimeTagger.TimeTaggerBase_getInvertedChannel(self, channel)

    def isUnusedChannel(self, channel: "int") -> "bool":
        r"""isUnusedChannel(self, channel) -> bool"""
        return _TimeTagger.TimeTaggerBase_isUnusedChannel(self, channel)

    def __getConfiguration(self) -> "std::string":
        r"""__getConfiguration(self) -> std::string"""
        return _TimeTagger.TimeTaggerBase___getConfiguration(self)

    def setInputDelay(self, channel: "int", delay: "long long") -> "void":
        r"""setInputDelay(self, channel, delay)"""
        return _TimeTagger.TimeTaggerBase_setInputDelay(self, channel, delay)

    def setDelayHardware(self, channel: "int", delay: "long long") -> "void":
        r"""setDelayHardware(self, channel, delay)"""
        return _TimeTagger.TimeTaggerBase_setDelayHardware(self, channel, delay)

    def setDelaySoftware(self, channel: "int", delay: "long long") -> "void":
        r"""setDelaySoftware(self, channel, delay)"""
        return _TimeTagger.TimeTaggerBase_setDelaySoftware(self, channel, delay)

    def getInputDelay(self, channel: "int") -> "long long":
        r"""getInputDelay(self, channel) -> long long"""
        return _TimeTagger.TimeTaggerBase_getInputDelay(self, channel)

    def getDelaySoftware(self, channel: "int") -> "long long":
        r"""getDelaySoftware(self, channel) -> long long"""
        return _TimeTagger.TimeTaggerBase_getDelaySoftware(self, channel)

    def getDelayHardware(self, channel: "int") -> "long long":
        r"""getDelayHardware(self, channel) -> long long"""
        return _TimeTagger.TimeTaggerBase_getDelayHardware(self, channel)

    def setDeadtime(self, channel: "int", deadtime: "long long") -> "long long":
        r"""setDeadtime(self, channel, deadtime) -> long long"""
        return _TimeTagger.TimeTaggerBase_setDeadtime(self, channel, deadtime)

    def getDeadtime(self, channel: "int") -> "long long":
        r"""getDeadtime(self, channel) -> long long"""
        return _TimeTagger.TimeTaggerBase_getDeadtime(self, channel)

    def setTestSignal(self, *args) -> "void":
        r"""
        setTestSignal(self, channel, enabled)
        setTestSignal(self, channel, enabled)
        """
        return _TimeTagger.TimeTaggerBase_setTestSignal(self, *args)

    def getTestSignal(self, channel: "int") -> "bool":
        r"""getTestSignal(self, channel) -> bool"""
        return _TimeTagger.TimeTaggerBase_getTestSignal(self, channel)

    def setSoftwareClock(self, input_channel: "int", input_frequency: "double" = 10e6, averaging_periods: "double" = 1000, wait_until_locked: "bool" = True) -> "void":
        r"""setSoftwareClock(self, input_channel, input_frequency=10e6, averaging_periods=1000, wait_until_locked=True)"""
        return _TimeTagger.TimeTaggerBase_setSoftwareClock(self, input_channel, input_frequency, averaging_periods, wait_until_locked)

    def disableSoftwareClock(self) -> "void":
        r"""disableSoftwareClock(self)"""
        return _TimeTagger.TimeTaggerBase_disableSoftwareClock(self)

    def getSoftwareClockState(self) -> "SoftwareClockState":
        r"""getSoftwareClockState(self) -> SoftwareClockState"""
        return _TimeTagger.TimeTaggerBase_getSoftwareClockState(self)

    def getOverflows(self) -> "long long":
        r"""getOverflows(self) -> long long"""
        return _TimeTagger.TimeTaggerBase_getOverflows(self)

    def clearOverflows(self) -> "void":
        r"""clearOverflows(self)"""
        return _TimeTagger.TimeTaggerBase_clearOverflows(self)

    def getOverflowsAndClear(self) -> "long long":
        r"""getOverflowsAndClear(self) -> long long"""
        return _TimeTagger.TimeTaggerBase_getOverflowsAndClear(self)

    def sync(self, timeout=-1):
        r"""sync(self, timeout=-1) -> bool"""
        fence = self.getFence()
        return self.waitForFence(fence, timeout)

    def waitForFence(self, fence, timeout=-1):
        r"""waitForFence(self, fence, timeout=-1) -> bool"""
        return _timeout_handler(lambda t: self.__waitForFence(fence, t), timeout)

    def getConfiguration(self, *args, **kargs):
        r"""getConfiguration(...) -> json"""
        import json
        return json.loads(self.__getConfiguration(*args, **kargs))

    def __enter__(self):
        return self

    def __exit__(self, type, value, tb):
        if self.thisown:
            self.__swig_destroy__(self)
            self.this = None
        return False


# Register TimeTaggerBase in _TimeTagger:
_TimeTagger.TimeTaggerBase_swigregister(TimeTaggerBase)


class TimeTaggerVirtual(TimeTaggerBase):
    r"""Proxy of C++ TimeTaggerVirtual class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def replay(self, file: "std::string const &", begin: "long long" = 0, duration: "long long" = -1, queue: "bool" = True) -> "uint64_t":
        r"""replay(self, file, begin=0, duration=-1, queue=True) -> uint64_t"""
        return _TimeTagger.TimeTaggerVirtual_replay(self, file, begin, duration, queue)

    def stop(self) -> "void":
        r"""stop(self)"""
        return _TimeTagger.TimeTaggerVirtual_stop(self)

    def reset(self) -> "void":
        r"""reset(self)"""
        return _TimeTagger.TimeTaggerVirtual_reset(self)

    def __waitForCompletion(self, ID: "uint64_t" = 0, timeout: "int64_t" = -1) -> "bool":
        r"""__waitForCompletion(self, ID=0, timeout=-1) -> bool"""
        return _TimeTagger.TimeTaggerVirtual___waitForCompletion(self, ID, timeout)

    def setReplaySpeed(self, speed: "double") -> "void":
        r"""setReplaySpeed(self, speed)"""
        return _TimeTagger.TimeTaggerVirtual_setReplaySpeed(self, speed)

    def getReplaySpeed(self) -> "double":
        r"""getReplaySpeed(self) -> double"""
        return _TimeTagger.TimeTaggerVirtual_getReplaySpeed(self)

    def setConditionalFilter(self, trigger: "IntVector", filtered: "IntVector") -> "void":
        r"""setConditionalFilter(self, trigger, filtered)"""
        return _TimeTagger.TimeTaggerVirtual_setConditionalFilter(self, trigger, filtered)

    def clearConditionalFilter(self) -> "void":
        r"""clearConditionalFilter(self)"""
        return _TimeTagger.TimeTaggerVirtual_clearConditionalFilter(self)

    def getConditionalFilterTrigger(self) -> "std::vector< int,std::allocator< int > >":
        r"""getConditionalFilterTrigger(self) -> IntVector"""
        return _TimeTagger.TimeTaggerVirtual_getConditionalFilterTrigger(self)

    def getConditionalFilterFiltered(self) -> "std::vector< int,std::allocator< int > >":
        r"""getConditionalFilterFiltered(self) -> IntVector"""
        return _TimeTagger.TimeTaggerVirtual_getConditionalFilterFiltered(self)

    def getChannelList(self) -> "std::vector< int,std::allocator< int > >":
        r"""getChannelList(self) -> IntVector"""
        return _TimeTagger.TimeTaggerVirtual_getChannelList(self)

    def waitForCompletion(self, ID=0, timeout=-1):
        r"""waitForCompletion(self, ID=0, timeout=-1) -> bool"""
        return _timeout_handler(lambda t: self.__waitForCompletion(ID, t), timeout)

    __swig_destroy__ = _TimeTagger.delete_TimeTaggerVirtual


# Register TimeTaggerVirtual in _TimeTagger:
_TimeTagger.TimeTaggerVirtual_swigregister(TimeTaggerVirtual)

AccessMode_Listen = _TimeTagger.AccessMode_Listen

AccessMode_Control = _TimeTagger.AccessMode_Control

AccessMode_SynchronousControl = _TimeTagger.AccessMode_SynchronousControl


class TimeTaggerNetwork(TimeTaggerBase):
    r"""Proxy of C++ TimeTaggerNetwork class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def isConnected(self) -> "bool":
        r"""isConnected(self) -> bool"""
        return _TimeTagger.TimeTaggerNetwork_isConnected(self)

    def setTriggerLevel(self, channel: "int", voltage: "double") -> "void":
        r"""setTriggerLevel(self, channel, voltage)"""
        return _TimeTagger.TimeTaggerNetwork_setTriggerLevel(self, channel, voltage)

    def getTriggerLevel(self, channel: "int") -> "double":
        r"""getTriggerLevel(self, channel) -> double"""
        return _TimeTagger.TimeTaggerNetwork_getTriggerLevel(self, channel)

    def setConditionalFilter(self, trigger: "IntVector", filtered: "IntVector", hardwareDelayCompensation: "bool" = True) -> "void":
        r"""setConditionalFilter(self, trigger, filtered, hardwareDelayCompensation=True)"""
        return _TimeTagger.TimeTaggerNetwork_setConditionalFilter(self, trigger, filtered, hardwareDelayCompensation)

    def clearConditionalFilter(self) -> "void":
        r"""clearConditionalFilter(self)"""
        return _TimeTagger.TimeTaggerNetwork_clearConditionalFilter(self)

    def getConditionalFilterTrigger(self) -> "std::vector< int,std::allocator< int > >":
        r"""getConditionalFilterTrigger(self) -> IntVector"""
        return _TimeTagger.TimeTaggerNetwork_getConditionalFilterTrigger(self)

    def getConditionalFilterFiltered(self) -> "std::vector< int,std::allocator< int > >":
        r"""getConditionalFilterFiltered(self) -> IntVector"""
        return _TimeTagger.TimeTaggerNetwork_getConditionalFilterFiltered(self)

    def setTestSignalDivider(self, divider: "int") -> "void":
        r"""setTestSignalDivider(self, divider)"""
        return _TimeTagger.TimeTaggerNetwork_setTestSignalDivider(self, divider)

    def getTestSignalDivider(self) -> "int":
        r"""getTestSignalDivider(self) -> int"""
        return _TimeTagger.TimeTaggerNetwork_getTestSignalDivider(self)

    def getTestSignal(self, channel: "int") -> "bool":
        r"""getTestSignal(self, channel) -> bool"""
        return _TimeTagger.TimeTaggerNetwork_getTestSignal(self, channel)

    def setDelayClient(self, channel: "int", time: "long long") -> "void":
        r"""setDelayClient(self, channel, time)"""
        return _TimeTagger.TimeTaggerNetwork_setDelayClient(self, channel, time)

    def getDelayClient(self, channel: "int") -> "long long":
        r"""getDelayClient(self, channel) -> long long"""
        return _TimeTagger.TimeTaggerNetwork_getDelayClient(self, channel)

    def getHardwareDelayCompensation(self, channel: "int") -> "long long":
        r"""getHardwareDelayCompensation(self, channel) -> long long"""
        return _TimeTagger.TimeTaggerNetwork_getHardwareDelayCompensation(self, channel)

    def setNormalization(self, channels: "IntVector", state: "bool") -> "void":
        r"""setNormalization(self, channels, state)"""
        return _TimeTagger.TimeTaggerNetwork_setNormalization(self, channels, state)

    def getNormalization(self, channel: "int") -> "bool":
        r"""getNormalization(self, channel) -> bool"""
        return _TimeTagger.TimeTaggerNetwork_getNormalization(self, channel)

    def setHardwareBufferSize(self, size: "int") -> "void":
        r"""setHardwareBufferSize(self, size)"""
        return _TimeTagger.TimeTaggerNetwork_setHardwareBufferSize(self, size)

    def getHardwareBufferSize(self) -> "int":
        r"""getHardwareBufferSize(self) -> int"""
        return _TimeTagger.TimeTaggerNetwork_getHardwareBufferSize(self)

    def setStreamBlockSize(self, max_events: "int", max_latency: "int") -> "void":
        r"""setStreamBlockSize(self, max_events, max_latency)"""
        return _TimeTagger.TimeTaggerNetwork_setStreamBlockSize(self, max_events, max_latency)

    def getStreamBlockSizeEvents(self) -> "int":
        r"""getStreamBlockSizeEvents(self) -> int"""
        return _TimeTagger.TimeTaggerNetwork_getStreamBlockSizeEvents(self)

    def getStreamBlockSizeLatency(self) -> "int":
        r"""getStreamBlockSizeLatency(self) -> int"""
        return _TimeTagger.TimeTaggerNetwork_getStreamBlockSizeLatency(self)

    def setEventDivider(self, channel: "int", divider: "unsigned int") -> "void":
        r"""setEventDivider(self, channel, divider)"""
        return _TimeTagger.TimeTaggerNetwork_setEventDivider(self, channel, divider)

    def getEventDivider(self, channel: "int") -> "unsigned int":
        r"""getEventDivider(self, channel) -> unsigned int"""
        return _TimeTagger.TimeTaggerNetwork_getEventDivider(self, channel)

    def getSerial(self) -> "std::string":
        r"""getSerial(self) -> std::string"""
        return _TimeTagger.TimeTaggerNetwork_getSerial(self)

    def getModel(self) -> "std::string":
        r"""getModel(self) -> std::string"""
        return _TimeTagger.TimeTaggerNetwork_getModel(self)

    def getChannelNumberScheme(self) -> "int":
        r"""getChannelNumberScheme(self) -> int"""
        return _TimeTagger.TimeTaggerNetwork_getChannelNumberScheme(self)

    def getDACRange(self) -> "std::vector< double,std::allocator< double > >":
        r"""getDACRange(self) -> DoubleVector"""
        return _TimeTagger.TimeTaggerNetwork_getDACRange(self)

    def getChannelList(self, *args, **kwargs) -> "std::vector< int,std::allocator< int > >":
        r"""getChannelList(self, type=All) -> IntVector"""
        return _TimeTagger.TimeTaggerNetwork_getChannelList(self, *args, **kwargs)

    def getPsPerClock(self) -> "long long":
        r"""getPsPerClock(self) -> long long"""
        return _TimeTagger.TimeTaggerNetwork_getPsPerClock(self)

    def getPcbVersion(self) -> "std::string":
        r"""getPcbVersion(self) -> std::string"""
        return _TimeTagger.TimeTaggerNetwork_getPcbVersion(self)

    def getFirmwareVersion(self) -> "std::string":
        r"""getFirmwareVersion(self) -> std::string"""
        return _TimeTagger.TimeTaggerNetwork_getFirmwareVersion(self)

    def __getSensorData(self) -> "std::string":
        r"""__getSensorData(self) -> std::string"""
        return _TimeTagger.TimeTaggerNetwork___getSensorData(self)

    def setLED(self, bitmask: "uint32_t") -> "void":
        r"""setLED(self, bitmask)"""
        return _TimeTagger.TimeTaggerNetwork_setLED(self, bitmask)

    def __getDeviceLicense(self) -> "std::string":
        r"""__getDeviceLicense(self) -> std::string"""
        return _TimeTagger.TimeTaggerNetwork___getDeviceLicense(self)

    def setSoundFrequency(self, freq_hz: "uint32_t") -> "void":
        r"""setSoundFrequency(self, freq_hz)"""
        return _TimeTagger.TimeTaggerNetwork_setSoundFrequency(self, freq_hz)

    def setTimeTaggerNetworkStreamCompression(self, active: "bool") -> "void":
        r"""setTimeTaggerNetworkStreamCompression(self, active)"""
        return _TimeTagger.TimeTaggerNetwork_setTimeTaggerNetworkStreamCompression(self, active)

    def getOverflowsClient(self) -> "long long":
        r"""getOverflowsClient(self) -> long long"""
        return _TimeTagger.TimeTaggerNetwork_getOverflowsClient(self)

    def clearOverflowsClient(self) -> "void":
        r"""clearOverflowsClient(self)"""
        return _TimeTagger.TimeTaggerNetwork_clearOverflowsClient(self)

    def getOverflowsAndClearClient(self) -> "long long":
        r"""getOverflowsAndClearClient(self) -> long long"""
        return _TimeTagger.TimeTaggerNetwork_getOverflowsAndClearClient(self)

    def setInputImpedanceHigh(self, channel: "int", high_impedance: "bool") -> "void":
        r"""setInputImpedanceHigh(self, channel, high_impedance)"""
        return _TimeTagger.TimeTaggerNetwork_setInputImpedanceHigh(self, channel, high_impedance)

    def getInputImpedanceHigh(self, channel: "int") -> "bool":
        r"""getInputImpedanceHigh(self, channel) -> bool"""
        return _TimeTagger.TimeTaggerNetwork_getInputImpedanceHigh(self, channel)

    def setInputHysteresis(self, channel: "int", value: "int") -> "void":
        r"""setInputHysteresis(self, channel, value)"""
        return _TimeTagger.TimeTaggerNetwork_setInputHysteresis(self, channel, value)

    def getInputHysteresis(self, channel: "int") -> "int":
        r"""getInputHysteresis(self, channel) -> int"""
        return _TimeTagger.TimeTaggerNetwork_getInputHysteresis(self, channel)

    def getDeviceLicense(self, *args, **kargs):
        r"""getDeviceLicense(...) -> json"""
        import json
        return json.loads(self.__getDeviceLicense(*args, **kargs))

    def getSensorData(self, *args, **kargs):
        r"""getSensorData(...) -> json"""
        import json
        return json.loads(self.__getSensorData(*args, **kargs))

    __swig_destroy__ = _TimeTagger.delete_TimeTaggerNetwork


# Register TimeTaggerNetwork in _TimeTagger:
_TimeTagger.TimeTaggerNetwork_swigregister(TimeTaggerNetwork)


class TimeTagger(TimeTaggerBase):
    r"""Proxy of C++ TimeTagger class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def reset(self) -> "void":
        r"""reset(self)"""
        return _TimeTagger.TimeTagger_reset(self)

    def isChannelRegistered(self, chan: "int") -> "bool":
        r"""isChannelRegistered(self, chan) -> bool"""
        return _TimeTagger.TimeTagger_isChannelRegistered(self, chan)

    def setTestSignalDivider(self, divider: "int") -> "void":
        r"""setTestSignalDivider(self, divider)"""
        return _TimeTagger.TimeTagger_setTestSignalDivider(self, divider)

    def getTestSignalDivider(self) -> "int":
        r"""getTestSignalDivider(self) -> int"""
        return _TimeTagger.TimeTagger_getTestSignalDivider(self)

    def xtra_setAuxOutSignal(self, channel: "int", divider: "int", duty_cycle: "double" = 0.5) -> "void":
        r"""xtra_setAuxOutSignal(self, channel, divider, duty_cycle=0.5)"""
        return _TimeTagger.TimeTagger_xtra_setAuxOutSignal(self, channel, divider, duty_cycle)

    def xtra_getAuxOutSignalDivider(self, channel: "int") -> "int":
        r"""xtra_getAuxOutSignalDivider(self, channel) -> int"""
        return _TimeTagger.TimeTagger_xtra_getAuxOutSignalDivider(self, channel)

    def xtra_getAuxOutSignalDutyCycle(self, channel: "int") -> "double":
        r"""xtra_getAuxOutSignalDutyCycle(self, channel) -> double"""
        return _TimeTagger.TimeTagger_xtra_getAuxOutSignalDutyCycle(self, channel)

    def xtra_setAuxOut(self, channel: "int", enabled: "bool") -> "void":
        r"""xtra_setAuxOut(self, channel, enabled)"""
        return _TimeTagger.TimeTagger_xtra_setAuxOut(self, channel, enabled)

    def xtra_getAuxOut(self, channel: "int") -> "bool":
        r"""xtra_getAuxOut(self, channel) -> bool"""
        return _TimeTagger.TimeTagger_xtra_getAuxOut(self, channel)

    def xtra_setFanSpeed(self, percentage: "double" = -1) -> "void":
        r"""xtra_setFanSpeed(self, percentage=-1)"""
        return _TimeTagger.TimeTagger_xtra_setFanSpeed(self, percentage)

    def setTriggerLevel(self, channel: "int", voltage: "double") -> "void":
        r"""setTriggerLevel(self, channel, voltage)"""
        return _TimeTagger.TimeTagger_setTriggerLevel(self, channel, voltage)

    def getTriggerLevel(self, channel: "int") -> "double":
        r"""getTriggerLevel(self, channel) -> double"""
        return _TimeTagger.TimeTagger_getTriggerLevel(self, channel)

    def xtra_measureTriggerLevel(self, channel: "int") -> "double":
        r"""xtra_measureTriggerLevel(self, channel) -> double"""
        return _TimeTagger.TimeTagger_xtra_measureTriggerLevel(self, channel)

    def getHardwareDelayCompensation(self, channel: "int") -> "long long":
        r"""getHardwareDelayCompensation(self, channel) -> long long"""
        return _TimeTagger.TimeTagger_getHardwareDelayCompensation(self, channel)

    def setInputMux(self, channel: "int", mux_mode: "int") -> "void":
        r"""setInputMux(self, channel, mux_mode)"""
        return _TimeTagger.TimeTagger_setInputMux(self, channel, mux_mode)

    def getInputMux(self, channel: "int") -> "int":
        r"""getInputMux(self, channel) -> int"""
        return _TimeTagger.TimeTagger_getInputMux(self, channel)

    def setConditionalFilter(self, trigger: "IntVector", filtered: "IntVector", hardwareDelayCompensation: "bool" = True) -> "void":
        r"""setConditionalFilter(self, trigger, filtered, hardwareDelayCompensation=True)"""
        return _TimeTagger.TimeTagger_setConditionalFilter(self, trigger, filtered, hardwareDelayCompensation)

    def clearConditionalFilter(self) -> "void":
        r"""clearConditionalFilter(self)"""
        return _TimeTagger.TimeTagger_clearConditionalFilter(self)

    def getConditionalFilterTrigger(self) -> "std::vector< int,std::allocator< int > >":
        r"""getConditionalFilterTrigger(self) -> IntVector"""
        return _TimeTagger.TimeTagger_getConditionalFilterTrigger(self)

    def getConditionalFilterFiltered(self) -> "std::vector< int,std::allocator< int > >":
        r"""getConditionalFilterFiltered(self) -> IntVector"""
        return _TimeTagger.TimeTagger_getConditionalFilterFiltered(self)

    def setNormalization(self, channels: "IntVector", state: "bool") -> "void":
        r"""setNormalization(self, channels, state)"""
        return _TimeTagger.TimeTagger_setNormalization(self, channels, state)

    def getNormalization(self, channel: "int") -> "bool":
        r"""getNormalization(self, channel) -> bool"""
        return _TimeTagger.TimeTagger_getNormalization(self, channel)

    def setHardwareBufferSize(self, size: "int") -> "void":
        r"""setHardwareBufferSize(self, size)"""
        return _TimeTagger.TimeTagger_setHardwareBufferSize(self, size)

    def getHardwareBufferSize(self) -> "int":
        r"""getHardwareBufferSize(self) -> int"""
        return _TimeTagger.TimeTagger_getHardwareBufferSize(self)

    def setStreamBlockSize(self, max_events: "int", max_latency: "int") -> "void":
        r"""setStreamBlockSize(self, max_events, max_latency)"""
        return _TimeTagger.TimeTagger_setStreamBlockSize(self, max_events, max_latency)

    def getStreamBlockSizeEvents(self) -> "int":
        r"""getStreamBlockSizeEvents(self) -> int"""
        return _TimeTagger.TimeTagger_getStreamBlockSizeEvents(self)

    def getStreamBlockSizeLatency(self) -> "int":
        r"""getStreamBlockSizeLatency(self) -> int"""
        return _TimeTagger.TimeTagger_getStreamBlockSizeLatency(self)

    def setEventDivider(self, channel: "int", divider: "unsigned int") -> "void":
        r"""setEventDivider(self, channel, divider)"""
        return _TimeTagger.TimeTagger_setEventDivider(self, channel, divider)

    def getEventDivider(self, channel: "int") -> "unsigned int":
        r"""getEventDivider(self, channel) -> unsigned int"""
        return _TimeTagger.TimeTagger_getEventDivider(self, channel)

    def autoCalibration(self) -> "void":
        r"""autoCalibration(self)"""
        return _TimeTagger.TimeTagger_autoCalibration(self)

    def getSerial(self) -> "std::string":
        r"""getSerial(self) -> std::string"""
        return _TimeTagger.TimeTagger_getSerial(self)

    def getModel(self) -> "std::string":
        r"""getModel(self) -> std::string"""
        return _TimeTagger.TimeTagger_getModel(self)

    def getChannelNumberScheme(self) -> "int":
        r"""getChannelNumberScheme(self) -> int"""
        return _TimeTagger.TimeTagger_getChannelNumberScheme(self)

    def getDACRange(self) -> "std::vector< double,std::allocator< double > >":
        r"""getDACRange(self) -> DoubleVector"""
        return _TimeTagger.TimeTagger_getDACRange(self)

    def getDistributionCount(self) -> "void":
        r"""getDistributionCount(self)"""
        return _TimeTagger.TimeTagger_getDistributionCount(self)

    def getDistributionPSecs(self) -> "void":
        r"""getDistributionPSecs(self)"""
        return _TimeTagger.TimeTagger_getDistributionPSecs(self)

    def getChannelList(self, *args, **kwargs) -> "std::vector< int,std::allocator< int > >":
        r"""getChannelList(self, type=All) -> IntVector"""
        return _TimeTagger.TimeTagger_getChannelList(self, *args, **kwargs)

    def getPsPerClock(self) -> "long long":
        r"""getPsPerClock(self) -> long long"""
        return _TimeTagger.TimeTagger_getPsPerClock(self)

    def getPcbVersion(self) -> "std::string":
        r"""getPcbVersion(self) -> std::string"""
        return _TimeTagger.TimeTagger_getPcbVersion(self)

    def getFirmwareVersion(self) -> "std::string":
        r"""getFirmwareVersion(self) -> std::string"""
        return _TimeTagger.TimeTagger_getFirmwareVersion(self)

    def xtra_setClockSource(self, source: "int") -> "void":
        r"""xtra_setClockSource(self, source)"""
        return _TimeTagger.TimeTagger_xtra_setClockSource(self, source)

    def xtra_getClockSource(self) -> "int":
        r"""xtra_getClockSource(self) -> int"""
        return _TimeTagger.TimeTagger_xtra_getClockSource(self)

    def xtra_setClockAutoSelect(self, enabled: "bool") -> "void":
        r"""xtra_setClockAutoSelect(self, enabled)"""
        return _TimeTagger.TimeTagger_xtra_setClockAutoSelect(self, enabled)

    def xtra_getClockAutoSelect(self) -> "bool":
        r"""xtra_getClockAutoSelect(self) -> bool"""
        return _TimeTagger.TimeTagger_xtra_getClockAutoSelect(self)

    def xtra_setClockOut(self, enabled: "bool") -> "void":
        r"""xtra_setClockOut(self, enabled)"""
        return _TimeTagger.TimeTagger_xtra_setClockOut(self, enabled)

    def __getSensorData(self) -> "std::string":
        r"""__getSensorData(self) -> std::string"""
        return _TimeTagger.TimeTagger___getSensorData(self)

    def setLED(self, bitmask: "uint32_t") -> "void":
        r"""setLED(self, bitmask)"""
        return _TimeTagger.TimeTagger_setLED(self, bitmask)

    def disableLEDs(self, disabled: "bool") -> "void":
        r"""disableLEDs(self, disabled)"""
        return _TimeTagger.TimeTagger_disableLEDs(self, disabled)

    def __getDeviceLicense(self) -> "std::string":
        r"""__getDeviceLicense(self) -> std::string"""
        return _TimeTagger.TimeTagger___getDeviceLicense(self)

    def factoryAccess(self, pw: "uint32_t", addr: "uint32_t", data: "uint32_t", mask: "uint32_t", use_wb: "bool" = False) -> "uint32_t":
        r"""factoryAccess(self, pw, addr, data, mask, use_wb=False) -> uint32_t"""
        return _TimeTagger.TimeTagger_factoryAccess(self, pw, addr, data, mask, use_wb)

    def setSoundFrequency(self, freq_hz: "uint32_t") -> "void":
        r"""setSoundFrequency(self, freq_hz)"""
        return _TimeTagger.TimeTagger_setSoundFrequency(self, freq_hz)

    def enableFpgaLink(self, *args, **kwargs) -> "void":
        r"""enableFpgaLink(self, channels, destination_mac, interface=SFPP_10GE)"""
        return _TimeTagger.TimeTagger_enableFpgaLink(self, *args, **kwargs)

    def disableFpgaLink(self) -> "void":
        r"""disableFpgaLink(self)"""
        return _TimeTagger.TimeTagger_disableFpgaLink(self)

    def startServer(self, *args, **kwargs) -> "void":
        r"""startServer(self, access_mode, channels=std::vector< int >(), port=41101)"""
        return _TimeTagger.TimeTagger_startServer(self, *args, **kwargs)

    def isServerRunning(self) -> "bool":
        r"""isServerRunning(self) -> bool"""
        return _TimeTagger.TimeTagger_isServerRunning(self)

    def stopServer(self) -> "void":
        r"""stopServer(self)"""
        return _TimeTagger.TimeTagger_stopServer(self)

    def setTimeTaggerNetworkStreamCompression(self, active: "bool") -> "void":
        r"""setTimeTaggerNetworkStreamCompression(self, active)"""
        return _TimeTagger.TimeTagger_setTimeTaggerNetworkStreamCompression(self, active)

    def setInputImpedanceHigh(self, channel: "int", high_impedance: "bool") -> "void":
        r"""setInputImpedanceHigh(self, channel, high_impedance)"""
        return _TimeTagger.TimeTagger_setInputImpedanceHigh(self, channel, high_impedance)

    def getInputImpedanceHigh(self, channel: "int") -> "bool":
        r"""getInputImpedanceHigh(self, channel) -> bool"""
        return _TimeTagger.TimeTagger_getInputImpedanceHigh(self, channel)

    def setInputHysteresis(self, channel: "int", value: "int") -> "void":
        r"""setInputHysteresis(self, channel, value)"""
        return _TimeTagger.TimeTagger_setInputHysteresis(self, channel, value)

    def getInputHysteresis(self, channel: "int") -> "int":
        r"""getInputHysteresis(self, channel) -> int"""
        return _TimeTagger.TimeTagger_getInputHysteresis(self, channel)

    def getDeviceLicense(self, *args, **kargs):
        r"""getDeviceLicense(...) -> json"""
        import json
        return json.loads(self.__getDeviceLicense(*args, **kargs))

    def getSensorData(self, *args, **kargs):
        r"""getSensorData(...) -> json"""
        import json
        return json.loads(self.__getSensorData(*args, **kargs))

    __swig_destroy__ = _TimeTagger.delete_TimeTagger


# Register TimeTagger in _TimeTagger:
_TimeTagger.TimeTagger_swigregister(TimeTagger)


class Tag(object):
    r"""Proxy of C++ Tag class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Type_TimeTag = _TimeTagger.Tag_Type_TimeTag

    Type_Error = _TimeTagger.Tag_Type_Error

    Type_OverflowBegin = _TimeTagger.Tag_Type_OverflowBegin

    Type_OverflowEnd = _TimeTagger.Tag_Type_OverflowEnd

    Type_MissedEvents = _TimeTagger.Tag_Type_MissedEvents

    type = property(_TimeTagger.Tag_type_get, _TimeTagger.Tag_type_set, doc=r"""type""")
    reserved = property(_TimeTagger.Tag_reserved_get, _TimeTagger.Tag_reserved_set, doc=r"""reserved""")
    missed_events = property(_TimeTagger.Tag_missed_events_get, _TimeTagger.Tag_missed_events_set, doc=r"""missed_events""")
    channel = property(_TimeTagger.Tag_channel_get, _TimeTagger.Tag_channel_set, doc=r"""channel""")
    time = property(_TimeTagger.Tag_time_get, _TimeTagger.Tag_time_set, doc=r"""time""")

    def __init__(self):
        r"""__init__(self) -> Tag"""
        _TimeTagger.Tag_swiginit(self, _TimeTagger.new_Tag())
    __swig_destroy__ = _TimeTagger.delete_Tag


# Register Tag in _TimeTagger:
_TimeTagger.Tag_swigregister(Tag)


class IteratorBase(object):
    r"""Proxy of C++ IteratorBase class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _TimeTagger.delete_IteratorBase

    def start(self) -> "void":
        r"""start(self)"""
        return _TimeTagger.IteratorBase_start(self)

    def startFor(self, capture_duration: "long long", clear: "bool" = True) -> "void":
        r"""startFor(self, capture_duration, clear=True)"""
        return _TimeTagger.IteratorBase_startFor(self, capture_duration, clear)

    def __waitUntilFinished(self, timeout: "int64_t" = -1) -> "bool":
        r"""__waitUntilFinished(self, timeout=-1) -> bool"""
        return _TimeTagger.IteratorBase___waitUntilFinished(self, timeout)

    def stop(self) -> "void":
        r"""stop(self)"""
        return _TimeTagger.IteratorBase_stop(self)

    def clear(self) -> "void":
        r"""clear(self)"""
        return _TimeTagger.IteratorBase_clear(self)

    def isRunning(self) -> "bool":
        r"""isRunning(self) -> bool"""
        return _TimeTagger.IteratorBase_isRunning(self)

    def getCaptureDuration(self) -> "long long":
        r"""getCaptureDuration(self) -> long long"""
        return _TimeTagger.IteratorBase_getCaptureDuration(self)

    def __getConfiguration(self) -> "std::string":
        r"""__getConfiguration(self) -> std::string"""
        return _TimeTagger.IteratorBase___getConfiguration(self)

    def waitUntilFinished(self, timeout=-1):
        r"""waitUntilFinished(self, timeout=-1) -> bool"""
        return _timeout_handler(self.__waitUntilFinished, timeout)

    def getConfiguration(self, *args, **kargs):
        r"""getConfiguration(...) -> json"""
        import json
        return json.loads(self.__getConfiguration(*args, **kargs))

    def __enter__(self):
        return self

    def __exit__(self, type, value, tb):
        if self.thisown:
            self.__swig_destroy__(self)
            self.this = None
        return False


# Register IteratorBase in _TimeTagger:
_TimeTagger.IteratorBase_swigregister(IteratorBase)

LanguageUsed_Cpp = _TimeTagger.LanguageUsed_Cpp

LanguageUsed_Python = _TimeTagger.LanguageUsed_Python

LanguageUsed_Csharp = _TimeTagger.LanguageUsed_Csharp

LanguageUsed_Matlab = _TimeTagger.LanguageUsed_Matlab

LanguageUsed_Labview = _TimeTagger.LanguageUsed_Labview

LanguageUsed_Mathematica = _TimeTagger.LanguageUsed_Mathematica

LanguageUsed_Unknown = _TimeTagger.LanguageUsed_Unknown

FrontendType_Undefined = _TimeTagger.FrontendType_Undefined

FrontendType_WebApp = _TimeTagger.FrontendType_WebApp

FrontendType_Firefly = _TimeTagger.FrontendType_Firefly

FrontendType_Pyro5RPC = _TimeTagger.FrontendType_Pyro5RPC

FrontendType_UserFrontend = _TimeTagger.FrontendType_UserFrontend


def setLanguageInfo(pw: "std::uint32_t", language: "LanguageUsed", version: "std::string") -> "void":
    r"""setLanguageInfo(pw, language, version)"""
    return _TimeTagger.setLanguageInfo(pw, language, version)


def setFrontend(frontend: "FrontendType") -> "void":
    r"""setFrontend(frontend)"""
    return _TimeTagger.setFrontend(frontend)


UsageStatisticsStatus_Disabled = _TimeTagger.UsageStatisticsStatus_Disabled

UsageStatisticsStatus_Collecting = _TimeTagger.UsageStatisticsStatus_Collecting

UsageStatisticsStatus_CollectingAndUploading = _TimeTagger.UsageStatisticsStatus_CollectingAndUploading


def setUsageStatisticsStatus(new_status: "UsageStatisticsStatus") -> "void":
    r"""setUsageStatisticsStatus(new_status)"""
    return _TimeTagger.setUsageStatisticsStatus(new_status)


def getUsageStatisticsStatus() -> "UsageStatisticsStatus":
    r"""getUsageStatisticsStatus() -> UsageStatisticsStatus"""
    return _TimeTagger.getUsageStatisticsStatus()


def getUsageStatisticsReport() -> "std::string":
    r"""getUsageStatisticsReport() -> std::string"""
    return _TimeTagger.getUsageStatisticsReport()


def mergeStreamFiles(output_filename: "std::string const &", input_filenames: "StringVector", channel_offsets: "IntVector", time_offsets: "LongLongVector", overlap_only: "bool") -> "void":
    r"""mergeStreamFiles(output_filename, input_filenames, channel_offsets, time_offsets, overlap_only)"""
    return _TimeTagger.mergeStreamFiles(output_filename, input_filenames, channel_offsets, time_offsets, overlap_only)


class Combiner(IteratorBase):
    r"""Proxy of C++ Combiner class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, tagger: "TimeTaggerBase", channels: "IntVector"):
        r"""__init__(self, tagger, channels) -> Combiner"""
        _TimeTagger.Combiner_swiginit(self, _TimeTagger.new_Combiner(tagger, channels))
    __swig_destroy__ = _TimeTagger.delete_Combiner

    def getChannelCounts(self) -> "void":
        r"""getChannelCounts(self)"""
        return _TimeTagger.Combiner_getChannelCounts(self)

    def getData(self) -> "void":
        r"""getData(self)"""
        return _TimeTagger.Combiner_getData(self)

    def getChannel(self) -> "int":
        r"""getChannel(self) -> int"""
        return _TimeTagger.Combiner_getChannel(self)


# Register Combiner in _TimeTagger:
_TimeTagger.Combiner_swigregister(Combiner)


class CountBetweenMarkers(IteratorBase):
    r"""Proxy of C++ CountBetweenMarkers class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        r"""__init__(self, tagger, click_channel, begin_channel, end_channel=CHANNEL_UNUSED, n_values=1000) -> CountBetweenMarkers"""
        _TimeTagger.CountBetweenMarkers_swiginit(self, _TimeTagger.new_CountBetweenMarkers(*args, **kwargs))
    __swig_destroy__ = _TimeTagger.delete_CountBetweenMarkers

    def ready(self) -> "bool":
        r"""ready(self) -> bool"""
        return _TimeTagger.CountBetweenMarkers_ready(self)

    def getData(self) -> "void":
        r"""getData(self)"""
        return _TimeTagger.CountBetweenMarkers_getData(self)

    def getBinWidths(self) -> "void":
        r"""getBinWidths(self)"""
        return _TimeTagger.CountBetweenMarkers_getBinWidths(self)

    def getIndex(self) -> "void":
        r"""getIndex(self)"""
        return _TimeTagger.CountBetweenMarkers_getIndex(self)


# Register CountBetweenMarkers in _TimeTagger:
_TimeTagger.CountBetweenMarkers_swigregister(CountBetweenMarkers)


class CounterData(object):
    r"""Proxy of C++ CounterData class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _TimeTagger.delete_CounterData

    def getData(self) -> "void":
        r"""getData(self)"""
        return _TimeTagger.CounterData_getData(self)

    def getDataNormalized(self) -> "void":
        r"""getDataNormalized(self)"""
        return _TimeTagger.CounterData_getDataNormalized(self)

    def getDataTotalCounts(self) -> "void":
        r"""getDataTotalCounts(self)"""
        return _TimeTagger.CounterData_getDataTotalCounts(self)

    def getIndex(self) -> "void":
        r"""getIndex(self)"""
        return _TimeTagger.CounterData_getIndex(self)

    def getTime(self) -> "void":
        r"""getTime(self)"""
        return _TimeTagger.CounterData_getTime(self)

    def getOverflowMask(self) -> "void":
        r"""getOverflowMask(self)"""
        return _TimeTagger.CounterData_getOverflowMask(self)

    def getChannels(self) -> "void":
        r"""getChannels(self)"""
        return _TimeTagger.CounterData_getChannels(self)
    size = property(_TimeTagger.CounterData_size_get, doc=r"""size""")
    dropped_bins = property(_TimeTagger.CounterData_dropped_bins_get, doc=r"""dropped_bins""")
    overflow = property(_TimeTagger.CounterData_overflow_get, doc=r"""overflow""")

    def __enter__(self):
        return self

    def __exit__(self, type, value, tb):
        if self.thisown:
            self.__swig_destroy__(self)
            self.this = None
        return False


# Register CounterData in _TimeTagger:
_TimeTagger.CounterData_swigregister(CounterData)


class Counter(IteratorBase):
    r"""Proxy of C++ Counter class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, tagger: "TimeTaggerBase", channels: "IntVector", binwidth: "long long" = 1000000000, n_values: "int32_t" = 1):
        r"""__init__(self, tagger, channels, binwidth=1000000000, n_values=1) -> Counter"""
        _TimeTagger.Counter_swiginit(self, _TimeTagger.new_Counter(tagger, channels, binwidth, n_values))
    __swig_destroy__ = _TimeTagger.delete_Counter

    def getData(self, rolling: "bool" = True) -> "void":
        r"""getData(self, rolling=True)"""
        return _TimeTagger.Counter_getData(self, rolling)

    def getDataNormalized(self, rolling: "bool" = True) -> "void":
        r"""getDataNormalized(self, rolling=True)"""
        return _TimeTagger.Counter_getDataNormalized(self, rolling)

    def getDataTotalCounts(self) -> "void":
        r"""getDataTotalCounts(self)"""
        return _TimeTagger.Counter_getDataTotalCounts(self)

    def getIndex(self) -> "void":
        r"""getIndex(self)"""
        return _TimeTagger.Counter_getIndex(self)

    def getDataObject(self, remove: "bool" = False) -> "CounterData":
        r"""getDataObject(self, remove=False) -> CounterData"""
        return _TimeTagger.Counter_getDataObject(self, remove)


# Register Counter in _TimeTagger:
_TimeTagger.Counter_swigregister(Counter)

CoincidenceTimestamp_Last = _TimeTagger.CoincidenceTimestamp_Last

CoincidenceTimestamp_Average = _TimeTagger.CoincidenceTimestamp_Average

CoincidenceTimestamp_First = _TimeTagger.CoincidenceTimestamp_First

CoincidenceTimestamp_ListedFirst = _TimeTagger.CoincidenceTimestamp_ListedFirst


class Coincidences(IteratorBase):
    r"""Proxy of C++ Coincidences class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        r"""__init__(self, tagger, coincidenceGroups, coincidenceWindow, timestamp=Last) -> Coincidences"""
        _TimeTagger.Coincidences_swiginit(self, _TimeTagger.new_Coincidences(*args, **kwargs))
    __swig_destroy__ = _TimeTagger.delete_Coincidences

    def getChannels(self) -> "std::vector< int,std::allocator< int > >":
        r"""getChannels(self) -> IntVector"""
        return _TimeTagger.Coincidences_getChannels(self)

    def setCoincidenceWindow(self, coincidenceWindow: "long long") -> "void":
        r"""setCoincidenceWindow(self, coincidenceWindow)"""
        return _TimeTagger.Coincidences_setCoincidenceWindow(self, coincidenceWindow)


# Register Coincidences in _TimeTagger:
_TimeTagger.Coincidences_swigregister(Coincidences)


class Coincidence(Coincidences):
    r"""Proxy of C++ Coincidence class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        r"""__init__(self, tagger, channels, coincidenceWindow=1000, timestamp=Last) -> Coincidence"""
        _TimeTagger.Coincidence_swiginit(self, _TimeTagger.new_Coincidence(*args, **kwargs))

    def getChannel(self) -> "int":
        r"""getChannel(self) -> int"""
        return _TimeTagger.Coincidence_getChannel(self)
    __swig_destroy__ = _TimeTagger.delete_Coincidence


# Register Coincidence in _TimeTagger:
_TimeTagger.Coincidence_swigregister(Coincidence)


class Countrate(IteratorBase):
    r"""Proxy of C++ Countrate class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, tagger: "TimeTaggerBase", channels: "IntVector"):
        r"""__init__(self, tagger, channels) -> Countrate"""
        _TimeTagger.Countrate_swiginit(self, _TimeTagger.new_Countrate(tagger, channels))
    __swig_destroy__ = _TimeTagger.delete_Countrate

    def getData(self) -> "void":
        r"""getData(self)"""
        return _TimeTagger.Countrate_getData(self)

    def getCountsTotal(self) -> "void":
        r"""getCountsTotal(self)"""
        return _TimeTagger.Countrate_getCountsTotal(self)


# Register Countrate in _TimeTagger:
_TimeTagger.Countrate_swigregister(Countrate)


class DelayedChannel(IteratorBase):
    r"""Proxy of C++ DelayedChannel class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, tagger: "TimeTaggerBase", input_channel: "int", delay: "long long"):
        r"""__init__(self, tagger, input_channel, delay) -> DelayedChannel"""
        _TimeTagger.DelayedChannel_swiginit(self, _TimeTagger.new_DelayedChannel(tagger, input_channel, delay))
    __swig_destroy__ = _TimeTagger.delete_DelayedChannel

    def getChannel(self) -> "int":
        r"""getChannel(self) -> int"""
        return _TimeTagger.DelayedChannel_getChannel(self)

    def setDelay(self, delay: "long long") -> "void":
        r"""setDelay(self, delay)"""
        return _TimeTagger.DelayedChannel_setDelay(self, delay)


# Register DelayedChannel in _TimeTagger:
_TimeTagger.DelayedChannel_swigregister(DelayedChannel)


class TriggerOnCountrate(IteratorBase):
    r"""Proxy of C++ TriggerOnCountrate class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, tagger: "TimeTaggerBase", input_channel: "int", reference_countrate: "double", hysteresis: "double", time_window: "long long"):
        r"""__init__(self, tagger, input_channel, reference_countrate, hysteresis, time_window) -> TriggerOnCountrate"""
        _TimeTagger.TriggerOnCountrate_swiginit(self, _TimeTagger.new_TriggerOnCountrate(tagger, input_channel, reference_countrate, hysteresis, time_window))
    __swig_destroy__ = _TimeTagger.delete_TriggerOnCountrate

    def getChannelAbove(self) -> "int":
        r"""getChannelAbove(self) -> int"""
        return _TimeTagger.TriggerOnCountrate_getChannelAbove(self)

    def getChannelBelow(self) -> "int":
        r"""getChannelBelow(self) -> int"""
        return _TimeTagger.TriggerOnCountrate_getChannelBelow(self)

    def getChannels(self) -> "std::vector< int,std::allocator< int > >":
        r"""getChannels(self) -> IntVector"""
        return _TimeTagger.TriggerOnCountrate_getChannels(self)

    def isAbove(self) -> "bool":
        r"""isAbove(self) -> bool"""
        return _TimeTagger.TriggerOnCountrate_isAbove(self)

    def isBelow(self) -> "bool":
        r"""isBelow(self) -> bool"""
        return _TimeTagger.TriggerOnCountrate_isBelow(self)

    def getCurrentCountrate(self) -> "double":
        r"""getCurrentCountrate(self) -> double"""
        return _TimeTagger.TriggerOnCountrate_getCurrentCountrate(self)

    def injectCurrentState(self) -> "bool":
        r"""injectCurrentState(self) -> bool"""
        return _TimeTagger.TriggerOnCountrate_injectCurrentState(self)


# Register TriggerOnCountrate in _TimeTagger:
_TimeTagger.TriggerOnCountrate_swigregister(TriggerOnCountrate)

GatedChannelInitial_Closed = _TimeTagger.GatedChannelInitial_Closed

GatedChannelInitial_Open = _TimeTagger.GatedChannelInitial_Open


class GatedChannel(IteratorBase):
    r"""Proxy of C++ GatedChannel class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        r"""__init__(self, tagger, input_channel, gate_start_channel, gate_stop_channel, initial=Closed) -> GatedChannel"""
        _TimeTagger.GatedChannel_swiginit(self, _TimeTagger.new_GatedChannel(*args, **kwargs))
    __swig_destroy__ = _TimeTagger.delete_GatedChannel

    def getChannel(self) -> "int":
        r"""getChannel(self) -> int"""
        return _TimeTagger.GatedChannel_getChannel(self)


# Register GatedChannel in _TimeTagger:
_TimeTagger.GatedChannel_swigregister(GatedChannel)


class FrequencyMultiplier(IteratorBase):
    r"""Proxy of C++ FrequencyMultiplier class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, tagger: "TimeTaggerBase", input_channel: "int", multiplier: "int32_t"):
        r"""__init__(self, tagger, input_channel, multiplier) -> FrequencyMultiplier"""
        _TimeTagger.FrequencyMultiplier_swiginit(self, _TimeTagger.new_FrequencyMultiplier(tagger, input_channel, multiplier))
    __swig_destroy__ = _TimeTagger.delete_FrequencyMultiplier

    def getChannel(self) -> "int":
        r"""getChannel(self) -> int"""
        return _TimeTagger.FrequencyMultiplier_getChannel(self)

    def getMultiplier(self) -> "int32_t":
        r"""getMultiplier(self) -> int32_t"""
        return _TimeTagger.FrequencyMultiplier_getMultiplier(self)


# Register FrequencyMultiplier in _TimeTagger:
_TimeTagger.FrequencyMultiplier_swigregister(FrequencyMultiplier)


class Iterator(IteratorBase):
    r"""Proxy of C++ Iterator class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, tagger: "TimeTaggerBase", channel: "int"):
        r"""__init__(self, tagger, channel) -> Iterator"""
        _TimeTagger.Iterator_swiginit(self, _TimeTagger.new_Iterator(tagger, channel))
    __swig_destroy__ = _TimeTagger.delete_Iterator

    def next(self) -> "long long":
        r"""next(self) -> long long"""
        return _TimeTagger.Iterator_next(self)

    def size(self) -> "uint64_t":
        r"""size(self) -> uint64_t"""
        return _TimeTagger.Iterator_size(self)


# Register Iterator in _TimeTagger:
_TimeTagger.Iterator_swigregister(Iterator)


class TimeTagStreamBuffer(object):
    r"""Proxy of C++ TimeTagStreamBuffer class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _TimeTagger.delete_TimeTagStreamBuffer

    def getOverflows(self) -> "void":
        r"""getOverflows(self)"""
        return _TimeTagger.TimeTagStreamBuffer_getOverflows(self)

    def getChannels(self) -> "void":
        r"""getChannels(self)"""
        return _TimeTagger.TimeTagStreamBuffer_getChannels(self)

    def getTimestamps(self) -> "void":
        r"""getTimestamps(self)"""
        return _TimeTagger.TimeTagStreamBuffer_getTimestamps(self)

    def getMissedEvents(self) -> "void":
        r"""getMissedEvents(self)"""
        return _TimeTagger.TimeTagStreamBuffer_getMissedEvents(self)

    def getEventTypes(self) -> "void":
        r"""getEventTypes(self)"""
        return _TimeTagger.TimeTagStreamBuffer_getEventTypes(self)
    size = property(_TimeTagger.TimeTagStreamBuffer_size_get, _TimeTagger.TimeTagStreamBuffer_size_set, doc=r"""size""")
    hasOverflows = property(_TimeTagger.TimeTagStreamBuffer_hasOverflows_get, _TimeTagger.TimeTagStreamBuffer_hasOverflows_set, doc=r"""hasOverflows""")
    tStart = property(_TimeTagger.TimeTagStreamBuffer_tStart_get, _TimeTagger.TimeTagStreamBuffer_tStart_set, doc=r"""tStart""")
    tGetData = property(_TimeTagger.TimeTagStreamBuffer_tGetData_get, _TimeTagger.TimeTagStreamBuffer_tGetData_set, doc=r"""tGetData""")

    def __enter__(self):
        return self

    def __exit__(self, type, value, tb):
        if self.thisown:
            self.__swig_destroy__(self)
            self.this = None
        return False


# Register TimeTagStreamBuffer in _TimeTagger:
_TimeTagger.TimeTagStreamBuffer_swigregister(TimeTagStreamBuffer)


class TimeTagStream(IteratorBase):
    r"""Proxy of C++ TimeTagStream class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, tagger: "TimeTaggerBase", n_max_events: "uint64_t", channels: "IntVector"):
        r"""__init__(self, tagger, n_max_events, channels) -> TimeTagStream"""
        _TimeTagger.TimeTagStream_swiginit(self, _TimeTagger.new_TimeTagStream(tagger, n_max_events, channels))
    __swig_destroy__ = _TimeTagger.delete_TimeTagStream

    def getCounts(self) -> "uint64_t":
        r"""getCounts(self) -> uint64_t"""
        return _TimeTagger.TimeTagStream_getCounts(self)

    def getData(self) -> "TimeTagStreamBuffer":
        r"""getData(self) -> TimeTagStreamBuffer"""
        return _TimeTagger.TimeTagStream_getData(self)


# Register TimeTagStream in _TimeTagger:
_TimeTagger.TimeTagStream_swigregister(TimeTagStream)


class Dump(IteratorBase):
    r"""Proxy of C++ Dump class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        r"""__init__(self, tagger, filename, max_tags, channels=std::vector< int >()) -> Dump"""
        _TimeTagger.Dump_swiginit(self, _TimeTagger.new_Dump(*args, **kwargs))
    __swig_destroy__ = _TimeTagger.delete_Dump


# Register Dump in _TimeTagger:
_TimeTagger.Dump_swigregister(Dump)


class StartStop(IteratorBase):
    r"""Proxy of C++ StartStop class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        r"""__init__(self, tagger, click_channel, start_channel=CHANNEL_UNUSED, binwidth=1000) -> StartStop"""
        _TimeTagger.StartStop_swiginit(self, _TimeTagger.new_StartStop(*args, **kwargs))
    __swig_destroy__ = _TimeTagger.delete_StartStop

    def getData(self) -> "void":
        r"""getData(self)"""
        return _TimeTagger.StartStop_getData(self)


# Register StartStop in _TimeTagger:
_TimeTagger.StartStop_swigregister(StartStop)


class TimeDifferences(IteratorBase):
    r"""Proxy of C++ TimeDifferences class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        r"""__init__(self, tagger, click_channel, start_channel=CHANNEL_UNUSED, next_channel=CHANNEL_UNUSED, sync_channel=CHANNEL_UNUSED, binwidth=1000, n_bins=1000, n_histograms=1) -> TimeDifferences"""
        _TimeTagger.TimeDifferences_swiginit(self, _TimeTagger.new_TimeDifferences(*args, **kwargs))
    __swig_destroy__ = _TimeTagger.delete_TimeDifferences

    def getData(self) -> "void":
        r"""getData(self)"""
        return _TimeTagger.TimeDifferences_getData(self)

    def getIndex(self) -> "void":
        r"""getIndex(self)"""
        return _TimeTagger.TimeDifferences_getIndex(self)

    def setMaxCounts(self, max_counts: "uint64_t") -> "void":
        r"""setMaxCounts(self, max_counts)"""
        return _TimeTagger.TimeDifferences_setMaxCounts(self, max_counts)

    def getCounts(self) -> "uint64_t":
        r"""getCounts(self) -> uint64_t"""
        return _TimeTagger.TimeDifferences_getCounts(self)

    def getHistogramIndex(self) -> "int32_t":
        r"""getHistogramIndex(self) -> int32_t"""
        return _TimeTagger.TimeDifferences_getHistogramIndex(self)

    def ready(self) -> "bool":
        r"""ready(self) -> bool"""
        return _TimeTagger.TimeDifferences_ready(self)


# Register TimeDifferences in _TimeTagger:
_TimeTagger.TimeDifferences_swigregister(TimeDifferences)


class Histogram2D(IteratorBase):
    r"""Proxy of C++ Histogram2D class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, tagger: "TimeTaggerBase", start_channel: "int", stop_channel_1: "int", stop_channel_2: "int", binwidth_1: "long long", binwidth_2: "long long", n_bins_1: "int32_t", n_bins_2: "int32_t"):
        r"""__init__(self, tagger, start_channel, stop_channel_1, stop_channel_2, binwidth_1, binwidth_2, n_bins_1, n_bins_2) -> Histogram2D"""
        _TimeTagger.Histogram2D_swiginit(self, _TimeTagger.new_Histogram2D(tagger, start_channel, stop_channel_1, stop_channel_2, binwidth_1, binwidth_2, n_bins_1, n_bins_2))
    __swig_destroy__ = _TimeTagger.delete_Histogram2D

    def getData(self) -> "void":
        r"""getData(self)"""
        return _TimeTagger.Histogram2D_getData(self)

    def getIndex(self) -> "void":
        r"""getIndex(self)"""
        return _TimeTagger.Histogram2D_getIndex(self)

    def getIndex_1(self) -> "void":
        r"""getIndex_1(self)"""
        return _TimeTagger.Histogram2D_getIndex_1(self)

    def getIndex_2(self) -> "void":
        r"""getIndex_2(self)"""
        return _TimeTagger.Histogram2D_getIndex_2(self)


# Register Histogram2D in _TimeTagger:
_TimeTagger.Histogram2D_swigregister(Histogram2D)


class HistogramND(IteratorBase):
    r"""Proxy of C++ HistogramND class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, tagger: "TimeTaggerBase", start_channel: "int", stop_channels: "IntVector", binwidths: "LongLongVector", n_bins: "IntVector"):
        r"""__init__(self, tagger, start_channel, stop_channels, binwidths, n_bins) -> HistogramND"""
        _TimeTagger.HistogramND_swiginit(self, _TimeTagger.new_HistogramND(tagger, start_channel, stop_channels, binwidths, n_bins))
    __swig_destroy__ = _TimeTagger.delete_HistogramND

    def getData(self) -> "void":
        r"""getData(self)"""
        return _TimeTagger.HistogramND_getData(self)

    def getIndex(self, dim: "int32_t" = 0) -> "void":
        r"""getIndex(self, dim=0)"""
        return _TimeTagger.HistogramND_getIndex(self, dim)


# Register HistogramND in _TimeTagger:
_TimeTagger.HistogramND_swigregister(HistogramND)


class TimeDifferencesND(IteratorBase):
    r"""Proxy of C++ TimeDifferencesND class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, tagger: "TimeTaggerBase", click_channel: "int", start_channel: "int", next_channels: "IntVector", sync_channels: "IntVector", n_histograms: "IntVector", binwidth: "long long", n_bins: "int32_t"):
        r"""__init__(self, tagger, click_channel, start_channel, next_channels, sync_channels, n_histograms, binwidth, n_bins) -> TimeDifferencesND"""
        _TimeTagger.TimeDifferencesND_swiginit(self, _TimeTagger.new_TimeDifferencesND(tagger, click_channel, start_channel, next_channels, sync_channels, n_histograms, binwidth, n_bins))
    __swig_destroy__ = _TimeTagger.delete_TimeDifferencesND

    def getData(self) -> "void":
        r"""getData(self)"""
        return _TimeTagger.TimeDifferencesND_getData(self)

    def getIndex(self) -> "void":
        r"""getIndex(self)"""
        return _TimeTagger.TimeDifferencesND_getIndex(self)


# Register TimeDifferencesND in _TimeTagger:
_TimeTagger.TimeDifferencesND_swigregister(TimeDifferencesND)


class Histogram(IteratorBase):
    r"""Proxy of C++ Histogram class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        r"""__init__(self, tagger, click_channel, start_channel=CHANNEL_UNUSED, binwidth=1000, n_bins=1000) -> Histogram"""
        _TimeTagger.Histogram_swiginit(self, _TimeTagger.new_Histogram(*args, **kwargs))
    __swig_destroy__ = _TimeTagger.delete_Histogram

    def getData(self) -> "void":
        r"""getData(self)"""
        return _TimeTagger.Histogram_getData(self)

    def getIndex(self) -> "void":
        r"""getIndex(self)"""
        return _TimeTagger.Histogram_getIndex(self)

    def __enter__(self):
        return self

    def __exit__(self, type, value, tb):
        if self.thisown:
            self.__swig_destroy__(self)
            self.this = None
        return False


# Register Histogram in _TimeTagger:
_TimeTagger.Histogram_swigregister(Histogram)


class HistogramLogBins(IteratorBase):
    r"""Proxy of C++ HistogramLogBins class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, tagger: "TimeTaggerBase", click_channel: "int", start_channel: "int", exp_start: "double", exp_stop: "double", n_bins: "int32_t"):
        r"""__init__(self, tagger, click_channel, start_channel, exp_start, exp_stop, n_bins) -> HistogramLogBins"""
        _TimeTagger.HistogramLogBins_swiginit(self, _TimeTagger.new_HistogramLogBins(tagger, click_channel, start_channel, exp_start, exp_stop, n_bins))
    __swig_destroy__ = _TimeTagger.delete_HistogramLogBins

    def getData(self) -> "void":
        r"""getData(self)"""
        return _TimeTagger.HistogramLogBins_getData(self)

    def getDataNormalizedCountsPerPs(self) -> "void":
        r"""getDataNormalizedCountsPerPs(self)"""
        return _TimeTagger.HistogramLogBins_getDataNormalizedCountsPerPs(self)

    def getDataNormalizedG2(self) -> "void":
        r"""getDataNormalizedG2(self)"""
        return _TimeTagger.HistogramLogBins_getDataNormalizedG2(self)

    def getBinEdges(self) -> "void":
        r"""getBinEdges(self)"""
        return _TimeTagger.HistogramLogBins_getBinEdges(self)


# Register HistogramLogBins in _TimeTagger:
_TimeTagger.HistogramLogBins_swigregister(HistogramLogBins)


class Correlation(IteratorBase):
    r"""Proxy of C++ Correlation class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        r"""__init__(self, tagger, channel_1, channel_2=CHANNEL_UNUSED, binwidth=1000, n_bins=1000) -> Correlation"""
        _TimeTagger.Correlation_swiginit(self, _TimeTagger.new_Correlation(*args, **kwargs))
    __swig_destroy__ = _TimeTagger.delete_Correlation

    def getData(self) -> "void":
        r"""getData(self)"""
        return _TimeTagger.Correlation_getData(self)

    def getDataNormalized(self) -> "void":
        r"""getDataNormalized(self)"""
        return _TimeTagger.Correlation_getDataNormalized(self)

    def getIndex(self) -> "void":
        r"""getIndex(self)"""
        return _TimeTagger.Correlation_getIndex(self)


# Register Correlation in _TimeTagger:
_TimeTagger.Correlation_swigregister(Correlation)

UNKNOWN = _TimeTagger.UNKNOWN

HIGH = _TimeTagger.HIGH

LOW = _TimeTagger.LOW


class Event(object):
    r"""Proxy of C++ Event class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    time = property(_TimeTagger.Event_time_get, _TimeTagger.Event_time_set, doc=r"""time""")
    state = property(_TimeTagger.Event_state_get, _TimeTagger.Event_state_set, doc=r"""state""")

    def __init__(self):
        r"""__init__(self) -> Event"""
        _TimeTagger.Event_swiginit(self, _TimeTagger.new_Event())
    __swig_destroy__ = _TimeTagger.delete_Event


# Register Event in _TimeTagger:
_TimeTagger.Event_swigregister(Event)


class Scope(IteratorBase):
    r"""Proxy of C++ Scope class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, tagger: "TimeTaggerBase", event_channels: "IntVector", trigger_channel: "int", window_size: "long long" = 1000000000, n_traces: "int32_t" = 1, n_max_events: "int32_t" = 1000):
        r"""__init__(self, tagger, event_channels, trigger_channel, window_size=1000000000, n_traces=1, n_max_events=1000) -> Scope"""
        _TimeTagger.Scope_swiginit(self, _TimeTagger.new_Scope(tagger, event_channels, trigger_channel, window_size, n_traces, n_max_events))
    __swig_destroy__ = _TimeTagger.delete_Scope

    def ready(self) -> "bool":
        r"""ready(self) -> bool"""
        return _TimeTagger.Scope_ready(self)

    def triggered(self) -> "int32_t":
        r"""triggered(self) -> int32_t"""
        return _TimeTagger.Scope_triggered(self)

    def getData(self) -> "std::vector< std::vector< Event,std::allocator< Event > >,std::allocator< std::vector< Event,std::allocator< Event > > > >":
        r"""getData(self) -> EventVectorVector"""
        return _TimeTagger.Scope_getData(self)

    def getWindowSize(self) -> "long long":
        r"""getWindowSize(self) -> long long"""
        return _TimeTagger.Scope_getWindowSize(self)


# Register Scope in _TimeTagger:
_TimeTagger.Scope_swigregister(Scope)


class SynchronizedMeasurements(object):
    r"""Proxy of C++ SynchronizedMeasurements class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, tagger: "TimeTaggerBase"):
        r"""__init__(self, tagger) -> SynchronizedMeasurements"""
        _TimeTagger.SynchronizedMeasurements_swiginit(self, _TimeTagger.new_SynchronizedMeasurements(tagger))
    __swig_destroy__ = _TimeTagger.delete_SynchronizedMeasurements

    def registerMeasurement(self, measurement: "IteratorBase") -> "void":
        r"""registerMeasurement(self, measurement)"""
        return _TimeTagger.SynchronizedMeasurements_registerMeasurement(self, measurement)

    def unregisterMeasurement(self, measurement: "IteratorBase") -> "void":
        r"""unregisterMeasurement(self, measurement)"""
        return _TimeTagger.SynchronizedMeasurements_unregisterMeasurement(self, measurement)

    def clear(self) -> "void":
        r"""clear(self)"""
        return _TimeTagger.SynchronizedMeasurements_clear(self)

    def start(self) -> "void":
        r"""start(self)"""
        return _TimeTagger.SynchronizedMeasurements_start(self)

    def stop(self) -> "void":
        r"""stop(self)"""
        return _TimeTagger.SynchronizedMeasurements_stop(self)

    def startFor(self, capture_duration: "long long", clear: "bool" = True) -> "void":
        r"""startFor(self, capture_duration, clear=True)"""
        return _TimeTagger.SynchronizedMeasurements_startFor(self, capture_duration, clear)

    def __waitUntilFinished(self, timeout: "int64_t" = -1) -> "bool":
        r"""__waitUntilFinished(self, timeout=-1) -> bool"""
        return _TimeTagger.SynchronizedMeasurements___waitUntilFinished(self, timeout)

    def isRunning(self) -> "bool":
        r"""isRunning(self) -> bool"""
        return _TimeTagger.SynchronizedMeasurements_isRunning(self)

    def getTagger(self) -> "TimeTaggerBase *":
        r"""getTagger(self) -> TimeTaggerBase"""
        return _TimeTagger.SynchronizedMeasurements_getTagger(self)

    def waitUntilFinished(self, timeout=-1):
        r"""waitUntilFinished(self, timeout=-1) -> bool"""
        return _timeout_handler(self.__waitUntilFinished, timeout)

    def __enter__(self):
        return self

    def __exit__(self, type, value, tb):
        if self.thisown:
            self.__swig_destroy__(self)
            self.this = None
        return False


# Register SynchronizedMeasurements in _TimeTagger:
_TimeTagger.SynchronizedMeasurements_swigregister(SynchronizedMeasurements)


class ConstantFractionDiscriminator(IteratorBase):
    r"""Proxy of C++ ConstantFractionDiscriminator class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, tagger: "TimeTaggerBase", channels: "IntVector", search_window: "long long"):
        r"""__init__(self, tagger, channels, search_window) -> ConstantFractionDiscriminator"""
        _TimeTagger.ConstantFractionDiscriminator_swiginit(self, _TimeTagger.new_ConstantFractionDiscriminator(tagger, channels, search_window))
    __swig_destroy__ = _TimeTagger.delete_ConstantFractionDiscriminator

    def getChannels(self) -> "std::vector< int,std::allocator< int > >":
        r"""getChannels(self) -> IntVector"""
        return _TimeTagger.ConstantFractionDiscriminator_getChannels(self)


# Register ConstantFractionDiscriminator in _TimeTagger:
_TimeTagger.ConstantFractionDiscriminator_swigregister(ConstantFractionDiscriminator)


class FileWriter(IteratorBase):
    r"""Proxy of C++ FileWriter class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, tagger: "TimeTaggerBase", filename: "std::string const &", channels: "IntVector"):
        r"""__init__(self, tagger, filename, channels) -> FileWriter"""
        _TimeTagger.FileWriter_swiginit(self, _TimeTagger.new_FileWriter(tagger, filename, channels))
    __swig_destroy__ = _TimeTagger.delete_FileWriter

    def split(self, *args, **kwargs) -> "void":
        r"""split(self, new_filename="")"""
        return _TimeTagger.FileWriter_split(self, *args, **kwargs)

    def setMaxFileSize(self, max_file_size: "uint64_t") -> "void":
        r"""setMaxFileSize(self, max_file_size)"""
        return _TimeTagger.FileWriter_setMaxFileSize(self, max_file_size)

    def getMaxFileSize(self) -> "uint64_t":
        r"""getMaxFileSize(self) -> uint64_t"""
        return _TimeTagger.FileWriter_getMaxFileSize(self)

    def getTotalEvents(self) -> "uint64_t":
        r"""getTotalEvents(self) -> uint64_t"""
        return _TimeTagger.FileWriter_getTotalEvents(self)

    def getTotalSize(self) -> "uint64_t":
        r"""getTotalSize(self) -> uint64_t"""
        return _TimeTagger.FileWriter_getTotalSize(self)

    def setMarker(self, marker: "std::string const &") -> "void":
        r"""setMarker(self, marker)"""
        return _TimeTagger.FileWriter_setMarker(self, marker)


# Register FileWriter in _TimeTagger:
_TimeTagger.FileWriter_swigregister(FileWriter)


class FileReader(object):
    r"""Proxy of C++ FileReader class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(self, filenames) -> FileReader
        __init__(self, filename) -> FileReader
        """
        _TimeTagger.FileReader_swiginit(self, _TimeTagger.new_FileReader(*args))
    __swig_destroy__ = _TimeTagger.delete_FileReader

    def hasData(self) -> "bool":
        r"""hasData(self) -> bool"""
        return _TimeTagger.FileReader_hasData(self)

    def getData(self, n_events: "uint64_t") -> "TimeTagStreamBuffer":
        r"""getData(self, n_events) -> TimeTagStreamBuffer"""
        return _TimeTagger.FileReader_getData(self, n_events)

    def __getConfiguration(self) -> "std::string":
        r"""__getConfiguration(self) -> std::string"""
        return _TimeTagger.FileReader___getConfiguration(self)

    def getChannelList(self) -> "std::vector< int,std::allocator< int > >":
        r"""getChannelList(self) -> IntVector"""
        return _TimeTagger.FileReader_getChannelList(self)

    def getLastMarker(self) -> "std::string":
        r"""getLastMarker(self) -> std::string"""
        return _TimeTagger.FileReader_getLastMarker(self)

    def getConfiguration(self, *args, **kargs):
        r"""getConfiguration(...) -> json"""
        import json
        return json.loads(self.__getConfiguration(*args, **kargs))

    def __enter__(self):
        return self

    def __exit__(self, type, value, tb):
        if self.thisown:
            self.__swig_destroy__(self)
            self.this = None
        return False


# Register FileReader in _TimeTagger:
_TimeTagger.FileReader_swigregister(FileReader)


class EventGenerator(IteratorBase):
    r"""Proxy of C++ EventGenerator class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        r"""__init__(self, tagger, trigger_channel, pattern, trigger_divider=1, divider_offset=0, stop_channel=CHANNEL_UNUSED) -> EventGenerator"""
        _TimeTagger.EventGenerator_swiginit(self, _TimeTagger.new_EventGenerator(*args, **kwargs))
    __swig_destroy__ = _TimeTagger.delete_EventGenerator

    def getChannel(self) -> "int":
        r"""getChannel(self) -> int"""
        return _TimeTagger.EventGenerator_getChannel(self)


# Register EventGenerator in _TimeTagger:
_TimeTagger.EventGenerator_swigregister(EventGenerator)


class CustomMeasurementBase(IteratorBase):
    r"""Proxy of C++ CustomMeasurementBase class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, tagger: "TimeTaggerBase"):
        r"""__init__(self, tagger) -> CustomMeasurementBase"""
        if self.__class__ == CustomMeasurementBase:
            _self = None
        else:
            _self = self
        _TimeTagger.CustomMeasurementBase_swiginit(self, _TimeTagger.new_CustomMeasurementBase(_self, tagger))
    __swig_destroy__ = _TimeTagger.delete_CustomMeasurementBase

    @staticmethod
    def stop_all_custom_measurements() -> "void":
        r"""stop_all_custom_measurements()"""
        return _TimeTagger.CustomMeasurementBase_stop_all_custom_measurements()

    def register_channel(self, channel: "int") -> "void":
        r"""register_channel(self, channel)"""
        return _TimeTagger.CustomMeasurementBase_register_channel(self, channel)

    def unregister_channel(self, channel: "int") -> "void":
        r"""unregister_channel(self, channel)"""
        return _TimeTagger.CustomMeasurementBase_unregister_channel(self, channel)

    def finalize_init(self) -> "void":
        r"""finalize_init(self)"""
        return _TimeTagger.CustomMeasurementBase_finalize_init(self)

    def is_running(self) -> "bool":
        r"""is_running(self) -> bool"""
        return _TimeTagger.CustomMeasurementBase_is_running(self)

    def _lock(self) -> "void":
        r"""_lock(self)"""
        return _TimeTagger.CustomMeasurementBase__lock(self)

    def _unlock(self) -> "void":
        r"""_unlock(self)"""
        return _TimeTagger.CustomMeasurementBase__unlock(self)

    def next_impl(self, incoming_tags: "std::vector< Tag,std::allocator< Tag > > &", begin_time: "long long", end_time: "long long") -> "bool":
        r"""next_impl(self, incoming_tags, begin_time, end_time) -> bool"""
        return _TimeTagger.CustomMeasurementBase_next_impl(self, incoming_tags, begin_time, end_time)

    def next_impl_cs(self, tags_ptr: "void *", num_tags: "uint64_t", begin_time: "long long", end_time: "long long") -> "void":
        r"""next_impl_cs(self, tags_ptr, num_tags, begin_time, end_time)"""
        return _TimeTagger.CustomMeasurementBase_next_impl_cs(self, tags_ptr, num_tags, begin_time, end_time)

    def clear_impl(self) -> "void":
        r"""clear_impl(self)"""
        return _TimeTagger.CustomMeasurementBase_clear_impl(self)

    def on_start(self) -> "void":
        r"""on_start(self)"""
        return _TimeTagger.CustomMeasurementBase_on_start(self)

    def on_stop(self) -> "void":
        r"""on_stop(self)"""
        return _TimeTagger.CustomMeasurementBase_on_stop(self)

    def __disown__(self):
        self.this.disown()
        _TimeTagger.disown_CustomMeasurementBase(self)
        return weakref.proxy(self)


# Register CustomMeasurementBase in _TimeTagger:
_TimeTagger.CustomMeasurementBase_swigregister(CustomMeasurementBase)


def CustomMeasurementBase_stop_all_custom_measurements() -> "void":
    r"""CustomMeasurementBase_stop_all_custom_measurements()"""
    return _TimeTagger.CustomMeasurementBase_stop_all_custom_measurements()


class FlimAbstract(IteratorBase):
    r"""Proxy of C++ FlimAbstract class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _TimeTagger.delete_FlimAbstract

    def isAcquiring(self) -> "bool":
        r"""isAcquiring(self) -> bool"""
        return _TimeTagger.FlimAbstract_isAcquiring(self)


# Register FlimAbstract in _TimeTagger:
_TimeTagger.FlimAbstract_swigregister(FlimAbstract)


class FlimBase(FlimAbstract):
    r"""Proxy of C++ FlimBase class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        r"""__init__(self, tagger, start_channel, click_channel, pixel_begin_channel, n_pixels, n_bins, binwidth, pixel_end_channel=CHANNEL_UNUSED, frame_begin_channel=CHANNEL_UNUSED, finish_after_outputframe=0, n_frame_average=1, pre_initialize=True) -> FlimBase"""
        if self.__class__ == FlimBase:
            _self = None
        else:
            _self = self
        _TimeTagger.FlimBase_swiginit(self, _TimeTagger.new_FlimBase(_self, *args, **kwargs))
    __swig_destroy__ = _TimeTagger.delete_FlimBase

    def initialize(self) -> "void":
        r"""initialize(self)"""
        return _TimeTagger.FlimBase_initialize(self)

    def frameReady(self, frame_number: "uint32_t", data: "UIntVector", pixel_begin_times: "LongLongVector", pixel_end_times: "LongLongVector", frame_begin_time: "long long", frame_end_time: "long long") -> "void":
        r"""frameReady(self, frame_number, data, pixel_begin_times, pixel_end_times, frame_begin_time, frame_end_time)"""
        return _TimeTagger.FlimBase_frameReady(self, frame_number, data, pixel_begin_times, pixel_end_times, frame_begin_time, frame_end_time)

    def __disown__(self):
        self.this.disown()
        _TimeTagger.disown_FlimBase(self)
        return weakref.proxy(self)


# Register FlimBase in _TimeTagger:
_TimeTagger.FlimBase_swigregister(FlimBase)


class FlimFrameInfo(object):
    r"""Proxy of C++ FlimFrameInfo class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _TimeTagger.delete_FlimFrameInfo

    def getFrameNumber(self) -> "int32_t":
        r"""getFrameNumber(self) -> int32_t"""
        return _TimeTagger.FlimFrameInfo_getFrameNumber(self)

    def isValid(self) -> "bool":
        r"""isValid(self) -> bool"""
        return _TimeTagger.FlimFrameInfo_isValid(self)

    def getPixelPosition(self) -> "uint32_t":
        r"""getPixelPosition(self) -> uint32_t"""
        return _TimeTagger.FlimFrameInfo_getPixelPosition(self)

    def getHistograms(self) -> "void":
        r"""getHistograms(self)"""
        return _TimeTagger.FlimFrameInfo_getHistograms(self)

    def getIntensities(self) -> "void":
        r"""getIntensities(self)"""
        return _TimeTagger.FlimFrameInfo_getIntensities(self)

    def getSummedCounts(self) -> "void":
        r"""getSummedCounts(self)"""
        return _TimeTagger.FlimFrameInfo_getSummedCounts(self)

    def getPixelBegins(self) -> "void":
        r"""getPixelBegins(self)"""
        return _TimeTagger.FlimFrameInfo_getPixelBegins(self)

    def getPixelEnds(self) -> "void":
        r"""getPixelEnds(self)"""
        return _TimeTagger.FlimFrameInfo_getPixelEnds(self)
    pixels = property(_TimeTagger.FlimFrameInfo_pixels_get, _TimeTagger.FlimFrameInfo_pixels_set, doc=r"""pixels""")
    bins = property(_TimeTagger.FlimFrameInfo_bins_get, _TimeTagger.FlimFrameInfo_bins_set, doc=r"""bins""")
    frame_number = property(_TimeTagger.FlimFrameInfo_frame_number_get, _TimeTagger.FlimFrameInfo_frame_number_set, doc=r"""frame_number""")
    pixel_position = property(_TimeTagger.FlimFrameInfo_pixel_position_get, _TimeTagger.FlimFrameInfo_pixel_position_set, doc=r"""pixel_position""")
    valid = property(_TimeTagger.FlimFrameInfo_valid_get, _TimeTagger.FlimFrameInfo_valid_set, doc=r"""valid""")

    def __enter__(self):
        return self

    def __exit__(self, type, value, tb):
        if self.thisown:
            self.__swig_destroy__(self)
            self.this = None
        return False


# Register FlimFrameInfo in _TimeTagger:
_TimeTagger.FlimFrameInfo_swigregister(FlimFrameInfo)


class Flim(FlimAbstract):
    r"""Proxy of C++ Flim class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        r"""__init__(self, tagger, start_channel, click_channel, pixel_begin_channel, n_pixels, n_bins, binwidth, pixel_end_channel=CHANNEL_UNUSED, frame_begin_channel=CHANNEL_UNUSED, finish_after_outputframe=0, n_frame_average=1, pre_initialize=True) -> Flim"""
        if self.__class__ == Flim:
            _self = None
        else:
            _self = self
        _TimeTagger.Flim_swiginit(self, _TimeTagger.new_Flim(_self, *args, **kwargs))
    __swig_destroy__ = _TimeTagger.delete_Flim

    def initialize(self) -> "void":
        r"""initialize(self)"""
        return _TimeTagger.Flim_initialize(self)

    def getReadyFrame(self, index: "int32_t" = -1) -> "void":
        r"""getReadyFrame(self, index=-1)"""
        return _TimeTagger.Flim_getReadyFrame(self, index)

    def getReadyFrameIntensity(self, index: "int32_t" = -1) -> "void":
        r"""getReadyFrameIntensity(self, index=-1)"""
        return _TimeTagger.Flim_getReadyFrameIntensity(self, index)

    def getCurrentFrame(self) -> "void":
        r"""getCurrentFrame(self)"""
        return _TimeTagger.Flim_getCurrentFrame(self)

    def getCurrentFrameIntensity(self) -> "void":
        r"""getCurrentFrameIntensity(self)"""
        return _TimeTagger.Flim_getCurrentFrameIntensity(self)

    def getSummedFrames(self, only_ready_frames: "bool" = True, clear_summed: "bool" = False) -> "void":
        r"""getSummedFrames(self, only_ready_frames=True, clear_summed=False)"""
        return _TimeTagger.Flim_getSummedFrames(self, only_ready_frames, clear_summed)

    def getSummedFramesIntensity(self, only_ready_frames: "bool" = True, clear_summed: "bool" = False) -> "void":
        r"""getSummedFramesIntensity(self, only_ready_frames=True, clear_summed=False)"""
        return _TimeTagger.Flim_getSummedFramesIntensity(self, only_ready_frames, clear_summed)

    def getReadyFrameEx(self, index: "int32_t" = -1) -> "FlimFrameInfo":
        r"""getReadyFrameEx(self, index=-1) -> FlimFrameInfo"""
        return _TimeTagger.Flim_getReadyFrameEx(self, index)

    def getCurrentFrameEx(self) -> "FlimFrameInfo":
        r"""getCurrentFrameEx(self) -> FlimFrameInfo"""
        return _TimeTagger.Flim_getCurrentFrameEx(self)

    def getSummedFramesEx(self, only_ready_frames: "bool" = True, clear_summed: "bool" = False) -> "FlimFrameInfo":
        r"""getSummedFramesEx(self, only_ready_frames=True, clear_summed=False) -> FlimFrameInfo"""
        return _TimeTagger.Flim_getSummedFramesEx(self, only_ready_frames, clear_summed)

    def getFramesAcquired(self) -> "uint32_t":
        r"""getFramesAcquired(self) -> uint32_t"""
        return _TimeTagger.Flim_getFramesAcquired(self)

    def getIndex(self) -> "void":
        r"""getIndex(self)"""
        return _TimeTagger.Flim_getIndex(self)

    def frameReady(self, frame_number: "uint32_t", data: "UIntVector", pixel_begin_times: "LongLongVector", pixel_end_times: "LongLongVector", frame_begin_time: "long long", frame_end_time: "long long") -> "void":
        r"""frameReady(self, frame_number, data, pixel_begin_times, pixel_end_times, frame_begin_time, frame_end_time)"""
        return _TimeTagger.Flim_frameReady(self, frame_number, data, pixel_begin_times, pixel_end_times, frame_begin_time, frame_end_time)

    def __disown__(self):
        self.this.disown()
        _TimeTagger.disown_Flim(self)
        return weakref.proxy(self)


# Register Flim in _TimeTagger:
_TimeTagger.Flim_swigregister(Flim)


class Sampler(IteratorBase):
    r"""Proxy of C++ Sampler class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, tagger: "TimeTaggerBase", trigger: "int", channels: "IntVector", max_triggers: "size_t"):
        r"""__init__(self, tagger, trigger, channels, max_triggers) -> Sampler"""
        _TimeTagger.Sampler_swiginit(self, _TimeTagger.new_Sampler(tagger, trigger, channels, max_triggers))
    __swig_destroy__ = _TimeTagger.delete_Sampler

    def getData(self) -> "void":
        r"""getData(self)"""
        return _TimeTagger.Sampler_getData(self)

    def getDataAsMask(self) -> "void":
        r"""getDataAsMask(self)"""
        return _TimeTagger.Sampler_getDataAsMask(self)


# Register Sampler in _TimeTagger:
_TimeTagger.Sampler_swigregister(Sampler)


class SyntheticSingleTag(IteratorBase):
    r"""Proxy of C++ SyntheticSingleTag class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        r"""__init__(self, tagger, base_channel=CHANNEL_UNUSED) -> SyntheticSingleTag"""
        _TimeTagger.SyntheticSingleTag_swiginit(self, _TimeTagger.new_SyntheticSingleTag(*args, **kwargs))
    __swig_destroy__ = _TimeTagger.delete_SyntheticSingleTag

    def trigger(self) -> "void":
        r"""trigger(self)"""
        return _TimeTagger.SyntheticSingleTag_trigger(self)

    def getChannel(self) -> "int":
        r"""getChannel(self) -> int"""
        return _TimeTagger.SyntheticSingleTag_getChannel(self)


# Register SyntheticSingleTag in _TimeTagger:
_TimeTagger.SyntheticSingleTag_swigregister(SyntheticSingleTag)


class FrequencyStabilityData(object):
    r"""Proxy of C++ FrequencyStabilityData class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _TimeTagger.delete_FrequencyStabilityData

    def getSTDD(self) -> "void":
        r"""getSTDD(self)"""
        return _TimeTagger.FrequencyStabilityData_getSTDD(self)

    def getADEV(self) -> "void":
        r"""getADEV(self)"""
        return _TimeTagger.FrequencyStabilityData_getADEV(self)

    def getMDEV(self) -> "void":
        r"""getMDEV(self)"""
        return _TimeTagger.FrequencyStabilityData_getMDEV(self)

    def getTDEV(self) -> "void":
        r"""getTDEV(self)"""
        return _TimeTagger.FrequencyStabilityData_getTDEV(self)

    def getHDEV(self) -> "void":
        r"""getHDEV(self)"""
        return _TimeTagger.FrequencyStabilityData_getHDEV(self)

    def getADEVScaled(self) -> "void":
        r"""getADEVScaled(self)"""
        return _TimeTagger.FrequencyStabilityData_getADEVScaled(self)

    def getHDEVScaled(self) -> "void":
        r"""getHDEVScaled(self)"""
        return _TimeTagger.FrequencyStabilityData_getHDEVScaled(self)

    def getTau(self) -> "void":
        r"""getTau(self)"""
        return _TimeTagger.FrequencyStabilityData_getTau(self)

    def getTracePhase(self) -> "void":
        r"""getTracePhase(self)"""
        return _TimeTagger.FrequencyStabilityData_getTracePhase(self)

    def getTraceFrequency(self) -> "void":
        r"""getTraceFrequency(self)"""
        return _TimeTagger.FrequencyStabilityData_getTraceFrequency(self)

    def getTraceFrequencyAbsolute(self, input_frequency: "double" = 0.0) -> "void":
        r"""getTraceFrequencyAbsolute(self, input_frequency=0.0)"""
        return _TimeTagger.FrequencyStabilityData_getTraceFrequencyAbsolute(self, input_frequency)

    def getTraceIndex(self) -> "void":
        r"""getTraceIndex(self)"""
        return _TimeTagger.FrequencyStabilityData_getTraceIndex(self)

    def __enter__(self):
        return self

    def __exit__(self, type, value, tb):
        if self.thisown:
            self.__swig_destroy__(self)
            self.this = None
        return False


# Register FrequencyStabilityData in _TimeTagger:
_TimeTagger.FrequencyStabilityData_swigregister(FrequencyStabilityData)


class FrequencyStability(IteratorBase):
    r"""Proxy of C++ FrequencyStability class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, tagger: "TimeTaggerBase", channel: "int", steps: "ULongLongVector", average: "long long" = 1000, trace_len: "uint64_t" = 1000):
        r"""__init__(self, tagger, channel, steps, average=1000, trace_len=1000) -> FrequencyStability"""
        _TimeTagger.FrequencyStability_swiginit(self, _TimeTagger.new_FrequencyStability(tagger, channel, steps, average, trace_len))
    __swig_destroy__ = _TimeTagger.delete_FrequencyStability

    def getDataObject(self) -> "FrequencyStabilityData":
        r"""getDataObject(self) -> FrequencyStabilityData"""
        return _TimeTagger.FrequencyStability_getDataObject(self)


# Register FrequencyStability in _TimeTagger:
_TimeTagger.FrequencyStability_swigregister(FrequencyStability)


class CustomMeasurement(CustomMeasurementBase):
    INCOMING_TAGS_DTYPE = numpy.dtype({'names': ['type', 'missed_events', 'channel', 'time'], 'formats': ['u1', '<u2', '<i4', '<i8'], 'offsets': [0, 2, 4, 8], 'itemsize': 16}, align=True)

    def __init__(self, time_tagger):
        CustomMeasurementBase.__init__(self, time_tagger)
        self.showError = True

        class TTMutex(object):
            def __init__(self, iter):
                self.iter = iter

            def __enter__(self):
                self.iter._lock()
                return self

            def __exit__(self, type, value, tb):
                self.iter._unlock()
                return False
        self.mutex = TTMutex(self)

    def stop(self, *args, **kwargs):
        if self.this:
            CustomMeasurementBase.stop(self, *args, **kwargs)

    def __exit__(self, *args, **kwargs):
        if self.this:
            self.stop()
        return CustomMeasurementBase.__exit__(self, *args, **kwargs)

    def process(self, incoming_tags, begin_time, end_time):
        if self.showError:
            print("ERROR: The process() method of the Python-CustomMeasurement must be overwritten!")
            self.showError = False

    def next_impl(self, incoming_tags, begin_time, end_time):
        tags = incoming_tags.view(self.INCOMING_TAGS_DTYPE)
        try:
            self.process(tags, begin_time, end_time)
        except Exception as inst:
            import traceback
            traceback.print_exc()
            raise inst

        return False


# Stop all custom measurements on shutdown. Else the virtual function might still be called while the interpreter is going to shut down.
__import__('atexit').register(CustomMeasurementBase.stop_all_custom_measurements)


def setLogger(callback):
    """
    Sets the notifier callback which is called for each log message

    :param callback: The callback for the log message, like lambda level, msg: print(msg)
    :return: returns nothing
    """
    class PyLogger(CustomLogger):
        def __init__(self, callback):
            CustomLogger.__init__(self)
            self.callback = callback
            self.enable()

        def Log(self, level, message):
            self.callback(level, message)
    setLogger.logger = None
    if callback:
        setLogger.logger = PyLogger(callback)


setLogger.logger = None


def freeTimeTagger(tagger: "TimeTaggerBase") -> "bool":
    r"""freeTimeTagger(tagger) -> bool"""
    if not isinstance(tagger, TimeTaggerBase):
        raise TypeError('in method \'freeTimeTagger\', argument 1 of type \'TimeTaggerBase\'')
    if tagger.this and tagger.thisown:
        tagger.__swig_destroy__(tagger)
        tagger.this = None
        return True
    return False


try:
    from enum import IntEnum
except:
    IntEnum = object
try:
    from enum import IntFlag
except:
    IntFlag = IntEnum


class CoincidenceTimestamp(IntEnum):
    Last = CoincidenceTimestamp_Last
    Average = CoincidenceTimestamp_Average
    First = CoincidenceTimestamp_First
    ListedFirst = CoincidenceTimestamp_ListedFirst


class Resolution(IntEnum):
    Standard = Resolution_Standard
    HighResA = Resolution_HighResA
    HighResB = Resolution_HighResB
    HighResC = Resolution_HighResC


class ChannelEdge(IntFlag):
    All = ChannelEdge_All
    Rising = ChannelEdge_Rising
    Falling = ChannelEdge_Falling
    HighResAll = ChannelEdge_HighResAll
    HighResRising = ChannelEdge_HighResRising
    HighResFalling = ChannelEdge_HighResFalling
    StandardAll = ChannelEdge_StandardAll
    StandardRising = ChannelEdge_StandardRising
    StandardFalling = ChannelEdge_StandardFalling


class UsageStatisticsStatus(IntEnum):
    Disabled = UsageStatisticsStatus_Disabled
    Collecting = UsageStatisticsStatus_Collecting
    CollectingAndUploading = UsageStatisticsStatus_CollectingAndUploading


class FrontendType(IntEnum):
    Undefined = FrontendType_Undefined
    WebApp = FrontendType_WebApp
    Firefly = FrontendType_Firefly
    Pyro5RPC = FrontendType_Pyro5RPC
    UserFrontend = FrontendType_UserFrontend


class LanguageUsed(IntEnum):
    Cpp = LanguageUsed_Cpp
    Python = LanguageUsed_Python
    Csharp = LanguageUsed_Csharp
    Matlab = LanguageUsed_Matlab
    Labview = LanguageUsed_Labview
    Mathematica = LanguageUsed_Mathematica
    Unknown = LanguageUsed_Unknown


class AccessMode(IntFlag):
    Listen = AccessMode_Listen
    Control = AccessMode_Control
    SynchronousControl = AccessMode_SynchronousControl


class TagType(IntEnum):
    TimeTag = Tag.Type_TimeTag
    Error = Tag.Type_Error
    OverflowBegin = Tag.Type_OverflowBegin
    OverflowEnd = Tag.Type_OverflowEnd
    MissedEvents = Tag.Type_MissedEvents


class GatedChannelInitial(IntEnum):
    Closed = GatedChannelInitial_Closed
    Open = GatedChannelInitial_Open


class FpgaLinkInterface(IntEnum):
    SFPP_10GE = FpgaLinkInterface_SFPP_10GE
# QSFPP_40GE = FpgaLinkInterface_QSFPP_40GE


del IntEnum
del IntFlag
